{
  "task": "Implement minimal request logging + correlation IDs in backend/ with a strict, git-apply-ready diff.\n\nGoal:\nAdd a lightweight middleware and logging filter so each request gets a UUID4 correlation ID that appears on ALL log lines during that request. Provide an env toggle LOG_REQUESTS (default true). Keep changes small, stdlib-only, and confined to backend/.\n\nRequirements:\n1) logging utils (backend/logging_utils.py):\n   - ContextVar to hold correlation_id; CorrelationIdFilter that sets record.correlation_id; helpers set_correlation_id(value)->token and clear_correlation_id(token); configure_logging(level=INFO) sets root format including %(correlation_id)s.\n2) middleware (backend/middleware/request_logging.py):\n   - Generate UUID4 per request; set token via set_correlation_id; always clear in finally using the token to avoid leakage.\n   - Respect LOG_REQUESTS env var (default true). When true, log one 'start' and one 'end' line per request with method, path, status, duration_ms, correlation_id (include fields in the log message so they render with the formatter).\n   - Ensure request.state.correlation_id is available.\n3) wiring (backend/main.py):\n   - Call configure_logging() once at startup (before adding middleware) so %(correlation_id)s appears on all log lines.\n   - Register RequestLoggingMiddleware. No API response shape changes.\n\nAcceptance Criteria:\n- All logs produced during a single request include the same correlation_id value.\n- LOG_REQUESTS=true (default): exactly one start and one end line per request; end line shows status and duration_ms.\n- LOG_REQUESTS=false: start/end lines suppressed, but other logs still include correlation_id.\n- Two consecutive /health calls produce different correlation IDs; no ContextVar leakage across requests.\n\nVerification Steps:\n1) Deploy with LOG_REQUESTS=true; curl GET /health twice; check logs show start/end with distinct cids and duration_ms.\n2) Set LOG_REQUESTS=false and redeploy; start/end lines cease, other logs still show cid.\n3) git apply --check and git apply --whitespace=fix succeed on the patch.\n\nConstraints:\n- Python stdlib only; minimal diffs; files limited to backend/.\n\nHARD OUTPUT CONTRACT (NON-NEGOTIABLE):\n- Output ONLY a valid unified diff (no prose, no markdown/code fences, no JSON, no placeholders, no ellipses ...).\n- Use LF newlines, UTF-8 (no BOM).\n- Each file section must apply with: git apply --whitespace=fix.\n- For new files, include: 'diff --git', 'new file mode 100644', '--- /dev/null', '+++ b/<path>', and correct '@@ -<start_old>,<len_old> +<start_new>,<len_new> @@' headers.\n- Do NOT include C-style block comments (/* ... */); use language-appropriate comments only (e.g., '# ...' in Python).\n- If truly no changes are required, emit a one-line no-op comment change inside backend/ (Python example: '# RMS GPT no-op touch: <UTC>').",
  "repo": "personal-agent-ste",
  "branch": "main",
  "path_prefix": "backend/",
  "k": 12,
  "session": "s1"
}
