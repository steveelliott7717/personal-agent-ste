{"hits":[{"id":482,"path":"backend/api.py","start_line":1,"end_line":87,"content":"# backend/api.py\nfrom __future__ import annotations\nimport os\nfrom pathlib import Path\n\nfrom fastapi import FastAPI, HTTPException\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom fastapi.responses import HTMLResponse, FileResponse\nfrom fastapi.staticfiles import StaticFiles\nfrom pydantic import BaseModel\nfrom dotenv import load_dotenv\n\n# Load .env for SUPABASE etc.\nload_dotenv()\n\n# your existing router entry\nfrom backend.agents.router_agent import route_request\n\nBASE = \"/app\"  # matches your frontend base\napp = FastAPI(title=\"Personal Agents API\")\n\n# ---------- SPA static serving at /app/ ----------\n# Serve built assets from frontend/dist (Vite build) and index fallback for SPA routes.\nDIST_DIR = (Path(__file__).resolve().parent.parent / \"frontend\" / \"dist\").resolve()\nINDEX_FILE = DIST_DIR / \"index.html\"\n\n# Serve built asset files (Vite emits to dist/assets/*). With base='/app/', URLs are /app/assets/...\nif (DIST_DIR / \"assets\").exists():\n    app.mount(f\"{BASE}/assets\", StaticFiles(directory=str(DIST_DIR / \"assets\")), name=\"assets\")\n\ndef _index_response() -> HTMLResponse:\n    if INDEX_FILE.exists():\n        return HTMLResponse(INDEX_FILE.read_text(encoding=\"utf-8\"))\n    raise HTTPException(status_code=404, detail=\"Frontend build not found. Run `npm run build` in /frontend.\")\n\n@app.get(BASE, include_in_schema=False, response_class=HTMLResponse)\ndef serve_index_root():\n    # GET /app -> index.html\n    return _index_response()\n\n@app.get(f\"{BASE}/\", include_in_schema=False, response_class=HTMLResponse)\ndef serve_index_slash():\n    # GET /app/ -> index.html\n    return _index_response()\n\n@app.get(f\"{BASE}\" + \"/{path:path}\", include_in_schema=False)\ndef spa_fallback(path: str):\n    # Let API continue to be handled by your /app/api/* routes\n    if path.startswith(\"api\"):\n        raise HTTPException(status_code=404)\n    # If a real file was requested (e.g., /app/assets/...), serve it directly\n    candidate = DIST_DIR / path\n    if candidate.is_file():\n        return FileResponse(str(candidate))\n    # Otherwise, return index.html for client-side routes\n    return _index_response()\n\n# CORS for local dev (frontend vite port)\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"http://localhost:5173\", \"http://127.0.0.1:5173\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\nclass RouteIn(BaseModel):\n    text: str\n    client_meta: dict | None = None\n    user_id: str | None = \"web-guest\"\n\n@app.post(f\"{BASE}/api/route\")\ndef route(incoming: RouteIn):\n    try:\n        agent, result = route_request(query=incoming.text, user_id=incoming.user_id or \"web-guest\")\n        # result might already be a dict/str from your make_response; normalize\n        if isinstance(result, dict):\n            payload = result\n        else:\n            payload = {\"agent\": agent, \"intent\": \"unknown\", \"message\": str(result)}\n        # attach meta if present\n        if incoming.client_meta:\n            payload.setdefault(\"meta\", {})[\"client_meta\"] = incoming.client_meta\n        return payload\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n","file_sha":null,"chunk_sha":null,"commit_sha":"HEAD","distance":null},{"id":483,"path":"backend/main.py","start_line":1,"end_line":225,"content":"# backend/main.py\nfrom __future__ import annotations\n\nimport os\nimport json\nfrom typing import Any, Dict, Tuple\n\nfrom fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse, RedirectResponse, HTMLResponse, FileResponse\nfrom fastapi.staticfiles import StaticFiles\nfrom pathlib import Path\nfrom starlette.middleware.base import BaseHTTPMiddleware\n\nfrom dotenv import load_dotenv\nload_dotenv()\n\n# ✅ package-qualified imports (works when running: uvicorn backend.main:app)\nfrom backend.agents.router_agent import route_request\nfrom backend.agents.repo_agent import propose_changes, answer_about_repo\nfrom backend.utils.nl_formatter import ensure_natural\nfrom backend.utils.agent_protocol import AgentResponse\nfrom backend.services import conversation as conv\n\n\napp = FastAPI(title=\"Personal Agent API\")\n\n# backend/main.py\nfrom fastapi import FastAPI\nimport os\n\napp = FastAPI()\n\n@app.get(\"/app/api/debug/supabase-key\")\nasync def debug_supabase_key():\n    key = os.getenv(\"SUPABASE_SERVICE_ROLE\")\n    if key:\n        return {\"SUPABASE_SERVICE_ROLE_start\": key[:8] + \"...\"}\n    return {\"SUPABASE_SERVICE_ROLE\": None}\n\n\n# -------------------- Health --------------------\n@app.get(\"/health\")\ndef health():\n    return {\"status\": \"ok\"}\n\n@app.get(\"/app/api/repo/health\")\ndef repo_health():\n    # Simple probe the Repo endpoints are up (and which model is configured)\n    return {\"ok\": True, \"model\": os.getenv(\"CHAT_MODEL\", \"gpt-5\")}\n\n@app.get(\"/\", include_in_schema=False)\ndef root_redirect():\n    return RedirectResponse(url=\"/app/\")\n\n# -------------------- Repo endpoints (bypass router) --------------------\n@app.post(\"/app/api/repo/query\")\ndef repo_query(payload: Dict[str, Any]):\n    q = (payload or {}).get(\"task\") or (payload or {}).get(\"question\") or (payload or {}).get(\"q\")\n    if not q:\n        raise HTTPException(status_code=400, detail=\"Missing 'task'/'question'/'q'\")\n    repo   = payload.get(\"repo\", \"personal-agent-ste\")\n    branch = payload.get(\"branch\", \"main\")\n    prefix = payload.get(\"path_prefix\")\n    k      = int(payload.get(\"k\", 8))\n    commit = payload.get(\"commit\")\n    session = payload.get(\"session\")\n    thread_n = payload.get(\"thread_n\")\n\n    try:\n        return answer_about_repo(\n            q,\n            repo=repo,\n            branch=branch,\n            k=k,\n            path_prefix=prefix,\n            commit=commit,\n            session=session,\n            thread_n=thread_n,\n        )\n    except Exception as e:\n        # bubble up precise error so we can see the RPC’s complaint\n        raise HTTPException(status_code=400, detail=str(e))\n\n\n@app.post(\"/app/api/repo/plan\")\ndef repo_plan(payload: Dict[str, Any]):\n    task = payload.get(\"task\")\n    if not task:\n        raise HTTPException(status_code=400, detail=\"Missing 'task'\")\n    repo   = payload.get(\"repo\", \"personal-agent-ste\")\n    branch = payload.get(\"branch\", \"main\")\n    prefix = payload.get(\"path_prefix\")  # e.g., \"backend/\" or \"frontend/\"\n    k      = int(payload.get(\"k\", 12))\n    session = payload.get(\"session\")\n    thread_n = payload.get(\"thread_n\")\n\n    out = propose_changes(\n        task,\n        repo=repo,\n        branch=branch,\n        commit=\"HEAD\",\n        k=k,\n        path_prefix=prefix,\n        session=session,\n        thread_n=thread_n,\n    )\n    return out\n\n\n@app.post(\"/app/api/repo/memory/reset\")\ndef repo_memory_reset(payload: Dict[str, Any]):\n    session = (payload or {}).get(\"session\")\n    if not session:\n        raise HTTPException(status_code=400, detail=\"Missing 'session'\")\n    deleted = conv.clear_session(session)\n    return {\"ok\": True, \"session\": session, \"deleted\": deleted}\n\n@app.post(\"/app/api/repo/memory/config\")\ndef repo_memory_config(payload: Dict[str, Any]):\n    session = (payload or {}).get(\"session\")\n    n = (payload or {}).get(\"n\")\n    if not session or n is None:\n        raise HTTPException(status_code=400, detail=\"Missing 'session' or 'n'\")\n    conv.set_session_n(session, int(n))\n    return {\"ok\": True, \"session\": session, \"n\": conv.get_session_n(session) or conv.default_n()}\n\n@app.get(\"/app/api/repo/memory/export\")\ndef repo_memory_export(session: str, limit: int = 50):\n    if not session:\n        raise HTTPException(status_code=400, detail=\"Missing 'session'\")\n    return {\"ok\": True, \"session\": session, \"limit\": int(limit), \"messages\": conv.export_messages(session, limit)}\n\n# -------------------- Middleware --------------------\nclass NaturalLanguageMiddleware(BaseHTTPMiddleware):\n    async def dispatch(self, request: Request, call_next):\n        try:\n            response = await call_next(request)\n\n            # Only transform JSONResponse payloads\n            if not isinstance(response, JSONResponse):\n                return response\n\n            # Clone response body safely\n            body_bytes = b\"\"\n            try:\n                async for chunk in response.body_iterator:  # type: ignore[attr-defined]\n                    body_bytes += chunk\n            except Exception:\n                return response  # if we can't read it, return as-is\n\n            response.body_iterator = None  # prevent double iteration\n\n            # If not JSON, passthrough\n            try:\n                payload = json.loads(body_bytes.decode(\"utf-8\"))\n            except Exception:\n                return JSONResponse(\n                    content=body_bytes.decode(\"utf-8\") if body_bytes else None,\n                    status_code=response.status_code,\n                )\n\n            # Naturalize\n            try:\n                formatted = ensure_natural(payload)\n            except Exception as e:\n                formatted = {\n                    \"agent\": (payload.get(\"agent\") if isinstance(payload, dict) else \"system\"),\n                    \"intent\": \"error\",\n                    \"message\": f\"Formatting error: {e}\",\n                    \"raw\": payload,\n                }\n\n            return JSONResponse(content=formatted, status_code=response.status_code)\n\n        except Exception as e:\n            return JSONResponse(\n                content={\"agent\": \"system\", \"intent\": \"error\", \"message\": f\"Middleware error: {e}\"},\n                status_code=500,\n            )\n\napp.add_middleware(NaturalLanguageMiddleware)\n\n# -------------------- Helpers --------------------\ndef _extract_query(query: str | None, body: Dict[str, Any] | None) -> Tuple[str | None, Dict[str, Any] | None]:\n    \"\"\"\n    Accepts either:\n      - form 'query'\n      - JSON { query | prompt | q }\n    \"\"\"\n    if query:\n        return query, body\n    if body and isinstance(body, dict):\n        q = body.get(\"query\") or body.get(\"prompt\") or body.get(\"q\")\n        return q, body\n    return None, body\n\ndef _normalize(agent: str, raw_result: Any) -> AgentResponse:\n    if isinstance(raw_result, str):\n        return {\"agent\": agent, \"intent\": \"say\", \"message\": raw_result}\n    if isinstance(raw_result, dict):\n        if \"agent\" not in raw_result:\n            raw_result = {\"agent\": agent, **raw_result}\n        raw_result.setdefault(\"intent\", \"unknown\")\n        return raw_result  # type: ignore[return-value]\n    if isinstance(raw_result, list):\n        return {\"agent\": agent, \"intent\": \"list\", \"data\": raw_result}\n    return {\"agent\": agent, \"intent\": \"unknown\", \"message\": str(raw_result)}\n\n# -------------------- Universal request endpoint (router path) --------------------\n@app.post(\"/api/request\")\n@app.post(\"/app/api/request\")\n@app.post(\"/api/route\")       # alias to support earlier clients/tests\n@app.post(\"/app/api/route\")   # alias to support earlier clients/tests\nasync def handle_request(request: Request):\n    # Try JSON first (don’t declare Body param so form requests don’t get validated as JSON)\n    body: Dict[str, Any] | None = None\n    try:\n        if request.headers.get(\"content-type\", \"\").lower().startswith(\"application/json\"):\n            body = await request.json()\n            if not isinstance(body, dict):\n                body = None\n    except Exception:\n        body = None\n\n    # Fall back to form field","file_sha":null,"chunk_sha":null,"commit_sha":"HEAD","distance":null},{"id":484,"path":"backend/main.py","start_line":1,"end_line":71,"content":"# alias to support earlier clients/tests\nasync def handle_request(request: Request):\n    # Try JSON first (don’t declare Body param so form requests don’t get validated as JSON)\n    body: Dict[str, Any] | None = None\n    try:\n        if request.headers.get(\"content-type\", \"\").lower().startswith(\"application/json\"):\n            body = await request.json()\n            if not isinstance(body, dict):\n                body = None\n    except Exception:\n        body = None\n\n    # Fall back to form fields\n    form_query: str | None = None\n    if body is None:\n        try:\n            form = await request.form()\n            if form:\n                form_query = form.get(\"query\") or form.get(\"prompt\") or form.get(\"q\")  # type: ignore[assignment]\n        except Exception:\n            form_query = None\n\n    q, _ = _extract_query(form_query, body)\n    if not q:\n        return JSONResponse(\n            {\"agent\": \"system\", \"intent\": \"error\", \"message\": \"Missing 'query' in form or JSON body\"},\n            status_code=400,\n        )\n\n    agent, raw_result = route_request(q)\n    resp = _normalize(agent, raw_result)\n\n    # Pre-format so clients without middleware still get a nice shape\n    try:\n        natural = ensure_natural(resp)\n    except Exception as e:\n        natural = {\n            \"agent\": resp.get(\"agent\", \"system\"),\n            \"intent\": \"error\",\n            \"message\": f\"Formatting error: {e}\",\n            \"raw\": resp,\n        }\n\n    return JSONResponse(natural)\n\n# -------------------- Static frontend (SPA at /app) --------------------\nstatic_dir = os.path.join(os.path.dirname(__file__), \"static\")\n\nif os.path.isdir(static_dir):\n    INDEX_FILE = Path(static_dir) / \"index.html\"\n\n    # Serve the SPA at /app (and optionally /)\n    app.mount(\"/app\", StaticFiles(directory=static_dir, html=True), name=\"static\")\n\n    @app.get(\"/app\", include_in_schema=False, response_class=HTMLResponse)\n    @app.get(\"/app/\", include_in_schema=False, response_class=HTMLResponse)\n    def serve_index():\n        if INDEX_FILE.exists():\n            return HTMLResponse(INDEX_FILE.read_text(encoding=\"utf-8\"))\n        raise HTTPException(status_code=404, detail=\"Frontend build not found.\")\n\n    # SPA fallback: return index.html for any /app/* path that isn't a real file\n    @app.get(\"/app/{path:path}\", include_in_schema=False, response_class=HTMLResponse)\n    def spa_fallback(path: str):\n        candidate = Path(static_dir) / path\n        if candidate.is_file():\n            return FileResponse(str(candidate))\n        if INDEX_FILE.exists():\n            return HTMLResponse(INDEX_FILE.read_text(encoding=\"utf-8\"))\n        raise HTTPException(status_code=404, detail=\"Frontend build not found.\")\n","file_sha":null,"chunk_sha":null,"commit_sha":"HEAD","distance":null},{"id":485,"path":"backend/rms.py","start_line":1,"end_line":36,"content":"# backend/rms.py\nfrom __future__ import annotations\nimport os\nfrom typing import Any, Dict, List\nfrom backend.services.supabase_service import supabase\n\nSUPABASE_RPC_1536 = \"repo_search_1536\"\nSUPABASE_RPC_1024 = \"repo_search_1024\"\n\ndef repo_search_raw(params: Dict[str, Any], *, dims: int) -> List[Dict[str, Any]]:\n    \"\"\"Dispatch to the right RPC based on dims. Params must include:\n       q (list[float]), repo, branch_in, prefix, match_count\n    \"\"\"\n    rpc_name = SUPABASE_RPC_1024 if dims == 1024 else SUPABASE_RPC_1536\n    # PostgREST requires named args for RPCs\n    payload = {\n        \"repo_in\": params[\"repo\"],\n        \"branch_in\": params[\"branch_in\"],\n        \"prefix_in\": params.get(\"prefix\"),\n        \"query_embedding\": params[\"q\"],\n        \"match_count\": params.get(\"match_count\", 8),\n    }\n    res = supabase.rpc(rpc_name, payload).execute()\n    return res.data or []\n\ndef repo_search(vec: List[float], *, repo: str, branch: str, k: int, prefix: str|None) -> List[Dict[str, Any]]:\n    dims = len(vec)\n    params = {\n        \"q\": vec,\n        \"repo\": repo,\n        \"branch_in\": branch,\n        \"prefix\": prefix,\n        \"match_count\": k,\n    }\n    return repo_search_raw(params, dims=dims)\n","file_sha":null,"chunk_sha":null,"commit_sha":"HEAD","distance":null},{"id":606,"path":"backend/static/assets/index-DNJdlJfi.js","start_line":1,"end_line":21,"content":"(function(){const t=document.createElement(\"link\").relList;if(t&&t.supports&&t.supports(\"modulepreload\"))return;for(const r of document.querySelectorAll('link[rel=\"modulepreload\"]'))s(r);new MutationObserver(r=>{for(const o of r)if(o.type===\"childList\")for(const i of o.addedNodes)i.tagName===\"LINK\"&&i.rel===\"modulepreload\"&&s(i)}).observe(document,{childList:!0,subtree:!0});function n(r){const o={};return r.integrity&&(o.integrity=r.integrity),r.referrerPolicy&&(o.referrerPolicy=r.referrerPolicy),r.crossOrigin===\"use-credentials\"?o.credentials=\"include\":r.crossOrigin===\"anonymous\"?o.credentials=\"omit\":o.credentials=\"same-origin\",o}function s(r){if(r.ep)return;r.ep=!0;const o=n(r);fetch(r.href,o)}})();/**\n* @vue/shared v3.5.18\n* (c) 2018-present Yuxi (Evan) You and Vue contributors\n* @license MIT\n**//*! #__NO_SIDE_EFFECTS__ */function hs(e){const t=Object.create(null);for(const n of e.split(\",\"))t[n]=1;return n=>n in t}const Y={},Et=[],De=()=>{},Yo=()=>!1,Sn=e=>e.charCodeAt(0)===111&&e.charCodeAt(1)===110&&(e.charCodeAt(2)>122||e.charCodeAt(2)<97),ps=e=>e.startsWith(\"onUpdate:\"),fe=Object.assign,gs=(e,t)=>{const n=e.indexOf(t);n>-1&&e.splice(n,1)},Xo=Object.prototype.hasOwnProperty,q=(e,t)=>Xo.call(e,t),H=Array.isArray,Rt=e=>En(e)===\"[object Map]\",Tr=e=>En(e)===\"[object Set]\",D=e=>typeof e==\"function\",ne=e=>typeof e==\"string\",ft=e=>typeof e==\"symbol\",ee=e=>e!==null&&typeof e==\"object\",Mr=e=>(ee(e)||D(e))&&D(e.then)&&D(e.catch),Ir=Object.prototype.toString,En=e=>Ir.call(e),Zo=e=>En(e).slice(8,-1),$r=e=>En(e)===\"[object Object]\",ms=e=>ne(e)&&e!==\"NaN\"&&e[0]!==\"-\"&&\"\"+parseInt(e,10)===e,Dt=hs(\",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted\"),Rn=e=>{const t=Object.create(null);return n=>t[n]||(t[n]=e(n))},ei=/-(\\w)/g,Se=Rn(e=>e.replace(ei,(t,n)=>n?n.toUpperCase():\"\")),ti=/\\B([A-Z])/g,at=Rn(e=>e.replace(ti,\"-$1\").toLowerCase()),Cn=Rn(e=>e.charAt(0).toUpperCase()+e.slice(1)),Hn=Rn(e=>e?`on${Cn(e)}`:\"\"),lt=(e,t)=>!Object.is(e,t),cn=(e,...t)=>{for(let n=0;n<e.length;n++)e[n](...t)},Yn=(e,t,n,s=!1)=>{Object.defineProperty(e,t,{configurable:!0,enumerable:!1,writable:s,value:n})},Xn=e=>{const t=parseFloat(e);return isNaN(t)?e:t};let Hs;const Pn=()=>Hs||(Hs=typeof globalThis<\"u\"?globalThis:typeof self<\"u\"?self:typeof window<\"u\"?window:typeof global<\"u\"?global:{});function _s(e){if(H(e)){const t={};for(let n=0;n<e.length;n++){const s=e[n],r=ne(s)?oi(s):_s(s);if(r)for(const o in r)t[o]=r[o]}return t}else if(ne(e)||ee(e))return e}const ni=/;(?![^(]*\\))/g,si=/:([^]+)/,ri=/\\/\\*[^]*?\\*\\//g;function oi(e){const t={};return e.replace(ri,\"\").split(ni).forEach(n=>{if(n){const s=n.split(si);s.length>1&&(t[s[0].trim()]=s[1].trim())}}),t}function An(e){let t=\"\";if(ne(e))t=e;else if(H(e))for(let n=0;n<e.length;n++){const s=An(e[n]);s&&(t+=s+\" \")}else if(ee(e))for(const n in e)e[n]&&(t+=n+\" \");return t.trim()}const ii=\"itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly\",li=hs(ii);function Nr(e){return!!e||e===\"\"}const Fr=e=>!!(e&&e.__v_isRef===!0),ot=e=>ne(e)?e:e==null?\"\":H(e)||ee(e)&&(e.toString===Ir||!D(e.toString))?Fr(e)?ot(e.value):JSON.stringify(e,Lr,2):String(e),Lr=(e,t)=>Fr(t)?Lr(e,t.value):Rt(t)?{[`Map(${t.size})`]:[...t.entries()].reduce((n,[s,r],o)=>(n[jn(s,o)+\" =>\"]=r,n),{})}:Tr(t)?{[`Set(${t.size})`]:[...t.values()].map(n=>jn(n))}:ft(t)?jn(t):ee(t)&&!H(t)&&!$r(t)?String(t):t,jn=(e,t=\"\")=>{var n;return ft(e)?`Symbol(${(n=e.description)!=null?n:t})`:e};/**\n* @vue/reactivity v3.5.18\n* (c) 2018-present Yuxi (Evan) You and Vue contributors\n* @license MIT\n**/let me;class ci{constructor(t=!1){this.detached=t,this._active=!0,this._on=0,this.effects=[],this.cleanups=[],this._isPaused=!1,this.parent=me,!t&&me&&(this.index=(me.scopes||(me.scopes=[])).push(this)-1)}get active(){return this._active}pause(){if(this._active){this._isPaused=!0;let t,n;if(this.scopes)for(t=0,n=this.scopes.length;t<n;t++)this.scopes[t].pause();for(t=0,n=this.effects.length;t<n;t++)this.effects[t].pause()}}resume(){if(this._active&&this._isPaused){this._isPaused=!1;let t,n;if(this.scopes)for(t=0,n=this.scopes.length;t<n;t++)this.scopes[t].resume();for(t=0,n=this.effects.length;t<n;t++)this.effects[t].resume()}}run(t){if(this._active){const n=me;try{return me=this,t()}finally{me=n}}}on(){++this._on===1&&(this.prevScope=me,me=this)}off(){this._on>0&&--this._on===0&&(me=this.prevScope,this.prevScope=void 0)}stop(t){if(this._active){this._active=!1;let n,s;for(n=0,s=this.effects.length;n<s;n++)this.effects[n].stop();for(this.effects.length=0,n=0,s=this.cleanups.length;n<s;n++)this.cleanups[n]();if(this.cleanups.length=0,this.scopes){for(n=0,s=this.scopes.length;n<s;n++)this.scopes[n].stop(!0);this.scopes.length=0}if(!this.detached&&this.parent&&!t){const r=this.parent.scopes.pop();r&&r!==this&&(this.parent.scopes[this.index]=r,r.index=this.index)}this.parent=void 0}}}function ui(){return me}let Z;const Dn=new WeakSet;class Hr{constructor(t){this.fn=t,this.deps=void 0,this.depsTail=void 0,this.flags=5,this.next=void 0,this.cleanup=void 0,this.scheduler=void 0,me&&me.active&&me.effects.push(this)}pause(){this.flags|=64}resume(){this.flags&64&&(this.flags&=-65,Dn.has(this)&&(Dn.delete(this),this.trigger()))}notify(){this.flags&2&&!(this.flags&32)||this.flags&8||Dr(this)}run(){if(!(this.flags&1))return this.fn();this.flags|=2,js(this),kr(this);const t=Z,n=Re;Z=this,Re=!0;try{return this.fn()}finally{Kr(this),Z=t,Re=n,this.flags&=-3}}stop(){if(this.flags&1){for(let t=this.deps;t;t=t.nextDep)bs(t);this.deps=this.depsTail=void 0,js(this),this.onStop&&this.onStop(),this.flags&=-2}}trigger(){this.flags&64?Dn.add(this):this.scheduler?this.scheduler():this.runIfDirty()}runIfDirty(){Zn(this)&&this.run()}get dirty(){return Zn(this)}}let jr=0,kt,Kt;function Dr(e,t=!1){if(e.flags|=8,t){e.next=Kt,Kt=e;return}e.next=kt,kt=e}function ys(){jr++}function vs(){if(--jr>0)return;if(Kt){let t=Kt;for(Kt=void 0;t;){const n=t.next;t.next=void 0,t.flags&=-9,t=n}}let e;for(;kt;){let t=kt;for(kt=void 0;t;){const n=t.next;if(t.next=void 0,t.flags&=-9,t.flags&1)try{t.trigger()}catch(s){e||(e=s)}t=n}}if(e)throw e}function kr(e){for(let t=e.deps;t;t=t.nextDep)t.version=-1,t.prevActiveLink=t.dep.activeLink,t.dep.activeLink=t}function Kr(e){let t,n=e.depsTail,s=n;for(;s;){const r=s.prevDep;s.version===-1?(s===n&&(n=r),bs(s),fi(s)):t=s,s.dep.activeLink=s.prevActiveLink,s.prevActiveLink=void 0,s=r}e.deps=t,e.depsTail=n}function Zn(e){for(let t=e.deps;t;t=t.nextDep)if(t.dep.version!==t.version||t.dep.computed&&(Vr(t.dep.computed)||t.dep.version!==t.version))return!0;return!!e._dirty}function Vr(e){if(e.flags&4&&!(e.flags&16)||(e.flags&=-17,e.globalVersion===zt)||(e.globalVersion=zt,!e.isSSR&&e.flags&128&&(!e.deps&&!e._dirty||!Zn(e))))return;e.flags|=2;const t=e.dep,n=Z,s=Re;Z=e,Re=!0;try{kr(e);const r=e.fn(e._value);(t.version===0||lt(r,e._value))&&(e.flags|=128,e._value=r,t.version++)}catch(r){throw t.version++,r}finally{Z=n,Re=s,Kr(e),e.flags&=-3}}function bs(e,t=!1){const{dep:n,prevSub:s,nextSub:r}=e;if(s&&(s.nextSub=r,e.prevSub=void 0),r&&(r.prevSub=s,e.nextSub=void 0),n.subs===e&&(n.subs=s,!s&&n.computed)){n.computed.flags&=-5;for(let o=n.computed.deps;o;o=o.nextDep)bs(o,!0)}!t&&!--n.sc&&n.map&&n.map.delete(n.key)}function fi(e){const{prevDep:t,nextDep:n}=e;t&&(t.nextDep=n,e.prevDep=void 0),n&&(n.prevDep=t,e.nextDep=void 0)}let Re=!0;const Br=[];function Qe(){Br.push(Re),Re=!1}function Je(){const e=Br.pop();Re=e===void 0?!0:e}function js(e){const{cleanup:t}=e;if(e.cleanup=void 0,t){const n=Z;Z=void 0;try{t()}finally{Z=n}}}let zt=0;class ai{constructor(t,n){this.sub=t,this.dep=n,this.version=n.version,this.nextDep=this.prevDep=this.nextSub=this.prevSub=this.prevActiveLink=void 0}}class xs{constructor(t){this.computed=t,this.version=0,this.activeLink=void 0,this.subs=void 0,this.map=void 0,this.key=void 0,this.sc=0,this.__v_skip=!0}track(t){if(!Z||!Re||Z===this.computed)return;let n=this.activeLink;if(n===void 0||n.sub!==Z)n=this.activeLink=new ai(Z,this),Z.deps?(n.prevDep=Z.depsTail,Z.depsTail.nextDep=n,Z.depsTail=n):Z.deps=Z.depsTail=n,Ur(n);else if(n.version===-1&&(n.version=this.version,n.nextDep)){const s=n.nextDep;s.prevDep=n.prevDep,n.prevDep&&(n.prevDep.nextDep=s),n.prevDep=Z.depsTail,n.nextDep=void 0,Z.depsTail.nextDep=n,Z.depsTail=n,Z.deps===n&&(Z.deps=s)}return n}trigger(t){this.version++,zt++,this.notify(t)}notify(t){ys();try{for(let n=this.subs;n;n=n.prevSub)n.sub.notify()&&n.sub.dep.notify()}finally{vs()}}}function Ur(e){if(e.dep.sc++,e.sub.flags&4){const t=e.dep.computed;if(t&&!e.dep.subs){t.flags|=20;for(let s=t.deps;s;s=s.nextDep)Ur(s)}const n=e.dep.subs;n!==e&&(e.prevSub=n,n&&(n.nextSub=e)),e.dep.subs=e}}const es=new WeakMap,mt=Symbol(\"\"),ts=Symbol(\"\"),Qt=Symbol(\"\");function ie(e,t,n){if(Re&&Z){let s=es.get(e);s||es.set(e,s=new Map);let r=s.get(n);r||(s.set(n,r=new xs),r.map=s,r.key=n),r.track()}}function We(e,t,n,s,r,o){const i=es.get(e);if(!i){zt++;return}const c=l=>{l&&l.trigger()};if(ys(),t===\"clear\")i.forEach(c);else{const l=H(e),d=l&&ms(n);if(l&&n===\"length\"){const f=Number(s);i.forEach((h,g)=>{(g===\"length\"||g===Qt||!ft(g)&&g>=f)&&c(h)})}else switch((n!==void 0||i.has(void 0))&&c(i.get(n)),d&&c(i.get(Qt)),t){case\"add\":l?d&&c(i.get(\"length\")):(c(i.get(mt)),Rt(e)&&c(i.get(ts)));break;case\"delete\":l||(c(i.get(mt)),Rt(e)&&c(i.get(ts)));break;case\"set\":Rt(e)&&c(i.get(mt));break}}vs()}function bt(e){const t=W(e);return t===e?t:(ie(t,\"iterate\",Qt),we(e)?t:t.map(oe))}function On(e){return ie(e=W(e),\"iterate\",Qt),e}const di={__proto__:null,[Symbol.iterator](){return kn(this,Symbol.iterator,oe)},concat(...e){return bt(this).concat(...e.map(t=>H(t)?bt(t):t))},entries(){return kn(this,\"entries\",e=>(e[1]=oe(e[1]),e))},every(e,t){return Ve(this,\"every\",e,t,void 0,arguments)},filter(e,t){return Ve(this,\"filter\",e,t,n=>n.map(oe),arguments)},find(e,t){return Ve(this,\"find\",e,t,oe,arguments)},findIndex(e,t){return Ve(this,\"findIndex\",e,t,void 0,arguments)},findLast(e,t){return Ve(this","file_sha":null,"chunk_sha":null,"commit_sha":"HEAD","distance":null},{"id":499,"path":"backend/agents/router_agent.py","start_line":121,"end_line":240,"content":"Return ONLY minified JSON in one of these schemas:\n\n1) Route to agent:\n{\"agent\":\"<slug>\",\"reason\":\"short reason\",\"confidence\":0.0-1.0,\"rewrite\":\"optional concise task phrasing\"}\n\n2) Answer directly (no agent call):\n{\"agent\":\"none\",\"response\":\"short answer\",\"reason\":\"why no agent is needed\",\"confidence\":0.0-1.0}\n\n3) Ask the user to choose (you are unsure which agent fits):\n{\"agent\":\"clarify\",\"question\":\"one short disambiguating question\",\"options\":[<slugs>],\n \"reason\":\"why you asked\",\"confidence\":0.0-1.0,\"rewrite\":\"optional best-guess task phrasing\"}\n\nHard rules:\n- If at least one agent in AGENT_CATALOG plausibly matches the user task, DO NOT choose agent=\"none\".\n- Prefer routing even if your confidence is moderate; use \"clarify\" only when you cannot pick between agents.\n- Use \"rewrite\" to turn vague user text into a crisp, actionable task for the chosen agent.\n\nGuidance (examples):\n- \"show today's meals\" -> route to the agent whose description/capabilities mention meals/meal planning/meal logs.\n- \"mark lunch done\" -> route to that same meals agent; include a rewrite like \"mark today's lunch complete\".\n- \"log today's workout\" -> route to workouts agent.\n- \"how much did I spend last week?\" -> route to finance agent.\n- \"hi\", \"thanks\", \"tell me a joke\" -> agent=\"none\".\n\"\"\"\n\n\ndef _build_prompt(user_text: str, user_id: str) -> str:\n    return (\n        f\"{ROUTER_SYSTEM}\\n\\n\"\n        f\"AGENT_CATALOG:\\n{json.dumps(_catalog())}\\n\\n\"\n        f\"USER_REQUEST:\\n{user_text}\\n\\n\"\n        \"Return ONLY the JSON.\"\n    )\n\ndef _parse_json(raw: str) -> Optional[Dict[str, Any]]:\n    if not isinstance(raw, str): return None\n    s = raw.strip()\n    if s.startswith(\"```\"):\n        s = s.strip(\"`\")\n        lines = s.splitlines()\n        if lines and lines[0].lower().startswith(\"json\"):\n            s = \"\\n\".join(lines[1:])\n    start, end = s.find(\"{\"), s.rfind(\"}\")\n    if start == -1 or end == -1 or end <= start: return None\n    try:\n        return json.loads(s[start:end+1])\n    except Exception:\n        logger.exception(\"[router] LLM parse error\")\n        return None\n\ndef _llm_route(user_text: str, user_id: str) -> Optional[Dict[str, Any]]:\n    try:\n        raw = reason_with_memory(\n            agent_name=\"router\",\n            query=_build_prompt(user_text, user_id),\n            namespace=\"routing\",\n            k=4,\n        )\n        obj = _parse_json(raw)\n        if not obj:\n            # LLM returned something we couldn't parse\n            _log_decision(\"router\", user_id, user_text, False, reason=\"parse_failed\")\n            return None\n\n        try:\n            obj[\"confidence\"] = float(obj.get(\"confidence\", 0))\n        except Exception:\n            obj[\"confidence\"] = 0.0\n\n        # Soft log that the LLM produced a routing proposal (final success/fail is logged later)\n        _log_decision(\n            \"router\",\n            user_id,\n            user_text,\n            True,\n            reason=\"llm_routed\",\n            confidence=obj.get(\"confidence\"),\n        )\n        return obj\n\n    except Exception as e:\n        logger.exception(\"[router] reasoner failed\")\n        _log_decision(\"router\", user_id, user_text, False, reason=\"reasoner_failed\", error=str(e))\n        return None\n\n\n# ----- public entry -----\ndef route_request(query: str, user_id: str = \"anon\") -> Tuple[str, dict | str]:\n    reg = _load_registry()\n    allowed = list(reg.keys())\n    print(f\"[router] incoming user={user_id!r} query={query!r} allowed={allowed}\")\n\n    try:\n        decision = _llm_route(query, user_id)\n\n        # Direct answer\n        if decision and decision.get(\"agent\") == \"none\":\n            _log_decision(\"router\", user_id, query, True, extra={\"reason\": decision.get(\"reason\"), \"confidence\": decision.get(\"confidence\")})\n            return \"router\", make_response(agent=\"router\", intent=\"answer\",\n                                        data={\"response\": decision.get(\"response\"),\n                                                \"reason\": decision.get(\"reason\"),\n                                                \"confidence\": decision.get(\"confidence\")})\n\n\n        # Clarify (or low confidence)\n        if not decision or decision.get(\"agent\") == \"clarify\" or decision.get(\"confidence\", 0) < 0.55:\n            opts = decision.get(\"options\") if decision and decision.get(\"options\") else allowed\n            q = decision.get(\"question\") if decision and decision.get(\"question\") else \"Which agent should handle this?\"\n            _log_decision(\"router\", user_id, query, False, extra={\"reason\": (decision or {}).get(\"reason\"), \"confidence\": (decision or {}).get(\"confidence\")})\n            return \"router\", make_response(agent=\"router\", intent=\"clarify\",\n                                        data={\"question\": q, \"options\": opts,\n                                                \"suggested_rewrite\": decision.get(\"rewrite\") if decision else None})\n\n\n        # Normal route\n        agent = str(decision.get(\"agent\") or \"\").strip().lower()\n        if agent in reg:\n            text = decision.get(\"rewrite\") or query\n\n            # Log to routing memory for future retrieval","file_sha":null,"chunk_sha":null,"commit_sha":"HEAD","distance":null},{"id":492,"path":"backend/agents/meals_agent.py","start_line":1,"end_line":79,"content":"# backend/agents/meals_agent.py\nfrom ._base_agent import BaseAgent\n\nFALLBACK_SYSTEM = \"\"\"\nYou are a meals operator. Plan floating daily meal cards (no fixed times), support swaps,\nand log completions. Read/write tables: recipe_templates, meal_plan, meal_log.\n\nReturn ONLY compact JSON with keys:\n- thoughts (string)\n- operations (array of {op, table, where?, order?, limit?, set?, values?})\n- response_template? (string)\n\nExamples:\n\n1) Build today's daylist (oldest-first by freshness):\n{\n  \"thoughts\": \"List today's meals from meal_plan by freshness\",\n  \"operations\": [\n    {\"op\":\"select\",\"table\":\"meal_plan\",\"where\":{\"date\":\"{{today}}\"},\"order\":[[\"freshness_rank\",\"asc\"]],\"limit\":50}\n  ]\n}\n\n2) Mark a meal complete and log it:\n{\n  \"thoughts\": \"Mark meal done and insert meal_log\",\n  \"operations\": [\n    {\"op\":\"update\",\"table\":\"meal_plan\",\"where\":{\"id\":\"{{meal_id}}\"},\"set\":{\"status\":\"done\"}},\n    {\"op\":\"insert\",\"table\":\"meal_log\",\"values\":{\n      \"meal_plan_id\":\"{{meal_id}}\",\"ts\":\"{{now}}\",\"notes\":\"auto\"\n    }}\n  ]\n}\n\n3) Add a planned meal for today (1 serving):\n{\n  \"thoughts\": \"Plan a new meal for today\",\n  \"operations\": [\n    {\"op\":\"insert\",\"table\":\"meal_plan\",\"values\":{\n      \"date\":\"{{today}}\",\"recipe_id\":\"{{recipe_id}}\",\"servings\":1,\"status\":\"planned\",\"freshness_rank\":0\n    }}\n  ]\n}\n\"\"\"\n\nclass MealsAgent(BaseAgent):\n    AGENT_META = {\n        \"slug\": \"meals\",\n        \"title\": \"Meals\",\n        \"description\": \"Plan daily meals, swap items, and log completions.\",\n        # Router metadata is inferred if omitted:\n        # \"module_path\": \"agents.meals_agent\",\n        # \"callable_name\": \"class:MealsAgent\",\n        \"namespaces\": [\"meals\"],\n        \"capabilities\": [\"Daylist\",\"Swap\",\"Complete\",\"Plan\"],\n        \"keywords\": [\"meal\",\"meals\",\"eat\",\"food\",\"recipe\",\"daylist\",\"breakfast\",\"lunch\",\"dinner\",\"snack\"],\n        \"status\": \"enabled\",\n        \"version\": \"v1\",\n        # Hints for the planner (also overridable via agent_settings.default_tables)\n        \"default_tables\": [\"recipe_templates\",\"meal_plan\",\"meal_log\"],\n        \"instruction_tags\": [],\n        \"fallback_system\": FALLBACK_SYSTEM,\n        # Post hooks can be configured here or in agent_settings.post_hooks\n        \"post_hooks\": [],\n    }\n\n    # Optional: choose instruction tags dynamically (kept minimal here)\n    def choose_tags(self, user_text: str):\n        text = (user_text or \"\").lower()\n        tags = []\n        if any(w in text for w in [\"plan\", \"add\", \"new meal\", \"daylist\"]):\n            tags.append(\"planning\")\n        if any(w in text for w in [\"swap\", \"replace\"]):\n            tags.append(\"swaps\")\n        if any(w in text for w in [\"done\", \"complete\", \"log\"]):\n            tags.append(\"logging\")\n        return tags\n\ndef handle_meals(query: str):\n    return MealsAgent().handle(query)","file_sha":null,"chunk_sha":null,"commit_sha":"HEAD","distance":null},{"id":493,"path":"backend/agents/mixins.py","start_line":1,"end_line":14,"content":"class SemanticAgentMixin:\n    \"\"\"Optional mixin for agents that want semantic memory + tools.\"\"\"\n    namespace: str = \"generic\"\n\n    def build_knowledge(self):\n        \"\"\"\n        Return rows to embed:\n        [{\"doc_id\": \"...\", \"text\": \"...\", \"metadata\": {...}}, ...]\n        \"\"\"\n        return []\n\n    def tools(self) -> dict:\n        \"\"\"Return {tool_name: callable} mapping (deterministic helpers).\"\"\"\n        return {}","file_sha":null,"chunk_sha":null,"commit_sha":"HEAD","distance":null},{"id":498,"path":"backend/agents/router_agent.py","start_line":1,"end_line":120,"content":"# backend/agents/router_agent.py\nfrom __future__ import annotations\nfrom typing import Tuple, Dict, Any, Optional, List, Callable\nimport json, logging, time, importlib\n\n# ✅ package-qualified imports\nfrom backend.services.supabase_service import supabase\nfrom backend.reasoner.policy import reason_with_memory\nfrom backend.utils.agent_protocol import make_response\nfrom backend.semantics.store import upsert as emb_upsert\nimport time\n\nfrom backend.services.supabase_service import supabase\n\ndef _log_decision(agent_slug: str, user_id: str, query_text: str, was_success: bool,\n                  latency_ms: int = 0, reason: str | None = None,\n                  confidence: float | None = None, error: str | None = None,\n                  extra: dict | None = None) -> None:\n    try:\n        payload = {\n            \"agent_slug\": agent_slug,\n            \"user_id\": user_id,\n            \"query_text\": query_text,\n            \"was_success\": was_success,\n            \"latency_ms\": latency_ms,\n            \"extra\": {\n                \"reason\": reason,\n                \"confidence\": confidence,\n                \"error\": error,\n                **(extra or {})\n            }\n        }\n        payload[\"extra\"] = {k: v for k, v in payload[\"extra\"].items() if v is not None}\n        supabase.table(\"agent_decisions\").insert(payload).execute()\n    except Exception:\n        logger.exception(\"[router] failed to log agent_decision\")\n\n\n\nROUTER_VERSION = \"2025-08-09-supabase-registry-v1\"\nlogger = logging.getLogger(\"router\")\nprint(f\"[router] loaded version={ROUTER_VERSION}\")\n\n# ----- Registry cache (auto refresh) -----\n_REG: Dict[str, Dict[str, Any]] = {}\n_LAST: float = 0.0\n_TTL = 60.0  # seconds\n\ndef _load_registry(force: bool = False) -> Dict[str, Dict[str, Any]]:\n    global _REG, _LAST\n    if not force and _REG and (time.time() - _LAST < _TTL):\n        return _REG\n\n    rows = []\n    try:\n        res = supabase.table(\"agents\").select(\"*\").eq(\"status\", \"enabled\").execute()\n        print(\"[router] fetched agents:\", [ (r.get(\"slug\"), r.get(\"module_path\"), r.get(\"callable_name\"), r.get(\"status\")) for r in rows ])\n\n        rows = getattr(res, \"data\", None) or []\n    except Exception:\n        logger.exception(\"[router] failed to read agents table\")\n        rows = []\n\n    reg: Dict[str, Dict[str, Any]] = {}\n    for r in rows:\n        slug = (r.get(\"slug\") or \"\").strip().lower()\n        module_path = r.get(\"module_path\") or f\"backend.agents.{slug}_agent\"\n        callable_name = r.get(\"callable_name\") or f\"handle_{slug}\"\n        if module_path.startswith(\"agents.\"):\n            module_path = \"backend.\" + module_path\n        try:\n            mod = importlib.import_module(module_path)\n            if callable_name.startswith(\"class:\"):\n                cls_name = callable_name.split(\":\", 1)[1]\n                Cls = getattr(mod, cls_name)\n                inst = Cls()\n                handle: Callable[[str], dict | str] = lambda q, _i=inst: _i.handle(q)\n            else:\n                handle = getattr(mod, callable_name)\n            reg[slug] = {\n                \"handle\": handle,\n                \"desc\": r.get(\"description\") or slug,\n                \"capabilities\": r.get(\"capabilities\") or [],\n                \"namespaces\": r.get(\"namespaces\") or [slug],\n            }\n            print(f\"[router] registered agent: {slug} -> {module_path}.{callable_name}\")\n        except Exception:\n            logger.exception(f\"[router] failed to import {module_path}.{callable_name} for slug={slug}\")\n\n    _REG = reg\n    _LAST = time.time()\n    print(f\"[router] registry loaded: {sorted(_REG.keys())}\")\n    return _REG\n\ndef _catalog() -> Dict[str, Any]:\n    reg = _load_registry()\n    return {k: {\"desc\": v[\"desc\"], \"capabilities\": v[\"capabilities\"]} for k, v in reg.items()}\n\n# ----- LLM prompt -----\nROUTER_SYSTEM = \"\"\"You are the routing coordinator for a personal-agents app.\n\nYou MUST choose an agent from AGENT_CATALOG when a user request is task-like or data-related\nand any catalog agent plausibly fits. Only use {\"agent\":\"none\", ...} for small-talk, greetings,\nor purely informational questions you can answer in one short sentence without calling an agent.\n\nReturn ONLY minified JSON in one of these schemas:\n\n1) Route to agent:\n{\"agent\":\"<slug>\",\"reason\":\"short reason\",\"confidence\":0.0-1.0,\"rewrite\":\"optional concise task phrasing\"}\n\n2) Answer directly (no agent call):\n{\"agent\":\"none\",\"response\":\"short answer\",\"reason\":\"why no agent is needed\",\"confidence\":0.0-1.0}\n\n3) Ask the user to choose (you are unsure which agent fits):\n{\"agent\":\"clarify\",\"question\":\"one short disambiguating question\",\"options\":[<slugs>],\n \"reason\":\"why you asked\",\"confidence\":0.0-1.0,\"rewrite\":\"optional best-guess task phrasing\"}\n\nHard rules:\n- If at least one agent in AGENT_CATALOG plausibly matches the user task, DO NOT choose agent=\"none\".\n- Prefer routing even if your confidence is moderate; use \"clarify\" only when you cannot pick between agents.","file_sha":null,"chunk_sha":null,"commit_sha":"HEAD","distance":null},{"id":504,"path":"backend/agents/_op_engine.py","start_line":1,"end_line":98,"content":"# backend/agents/_op_engine.py\nfrom typing import Any, Dict, List\nimport re, json\nfrom backend.services.supabase_service import supabase\n\ndef table_columns(table: str) -> List[str]:\n    try:\n        sample = supabase.table(table).select(\"*\").limit(1).execute().data or []\n        return list(sample[0].keys()) if sample else []\n    except Exception:\n        return []\n\ndef _prune_where(where: Any, columns: List[str]) -> Any:\n    if not where or not columns: return where\n    cols = set(columns)\n    if isinstance(where, str):\n        parts = re.split(r\"\\s+and\\s+\", where, flags=re.I)\n        kept = [p for p in parts if re.match(r\"\\s*([a-zA-Z0-9_]+)\\s*=\", p) and p.split(\"=\")[0].strip() in cols]\n        return \" AND \".join(kept) if kept else None\n    if isinstance(where, list):\n        pruned = [w for w in (_prune_where(w, columns) for w in where) if w]\n        return pruned or None\n    if isinstance(where, dict):\n        return {k:v for k,v in where.items() if k in cols} or None\n    return None\n\ndef _apply_where(q, where: Any):\n    if not where: return q\n    if isinstance(where, str):\n        parts = re.split(r\"\\s+and\\s+\", where, flags=re.I)\n        for cond in parts:\n            m = re.match(r\"\\s*([a-zA-Z0-9_]+)\\s*=\\s*(.+)\\s*$\", cond)\n            if not m: continue\n            key, val = m.group(1), m.group(2).strip().strip(\"'\\\"\")\n            q = q.eq(key, val)\n        return q\n    if isinstance(where, list):\n        for w in where: q = _apply_where(q, w)\n        return q\n    if isinstance(where, dict):\n        for k, v in where.items():\n            if isinstance(v, dict):\n                for oper, val in v.items():\n                    o = str(oper).lower()\n                    if   o == \">=\": q = q.gte(k, val)\n                    elif o == \"<=\": q = q.lte(k, val)\n                    elif o == \">\":  q = q.gt(k, val)\n                    elif o == \"<\":  q = q.lt(k, val)\n                    elif o == \"!=\": q = q.neq(k, val)\n                    elif o == \"like\": q = q.like(k, val)\n                    else: q = q.eq(k, val)\n            else:\n                q = q.eq(k, v)\n        return q\n    return q\n\ndef execute_ops(ops: List[Dict[str, Any]]) -> List[Any]:\n    out: List[Any] = []\n    for step in ops:\n        op = str(step.get(\"op\",\"\")).lower()\n        table = step.get(\"table\")\n        if not op or not table:\n            out.append({\"error\":\"missing op/table\",\"step\":step}); continue\n\n        cols = table_columns(table)\n        where = _prune_where(step.get(\"where\"), cols)\n\n        if op == \"select\":\n            q = supabase.table(table).select(\"*\")\n            q = _apply_where(q, where or {})\n            for pair in (step.get(\"order\") or []):\n                if isinstance(pair, list) and len(pair)==2:\n                    q = q.order(pair[0], desc=(str(pair[1]).lower()==\"desc\"))\n            if step.get(\"limit\"): q = q.limit(int(step[\"limit\"]))\n            out.append(q.execute().data or []); continue\n\n        if op == \"update\":\n            q = supabase.table(table).update(step.get(\"set\") or {})\n            q = _apply_where(q, where or {})\n            out.append(q.execute().data or []); continue\n\n        if op == \"insert\":\n            values = step.get(\"values\"); \n            if isinstance(values, dict): values = [values]\n            out.append(supabase.table(table).insert(values or []).execute().data or []); continue\n\n        if op == \"delete\":\n            q = supabase.table(table).delete()\n            q = _apply_where(q, where or {})\n            out.append(q.execute().data or []); continue\n\n        if op == \"upsert\":\n            values = step.get(\"values\"); \n            if isinstance(values, dict): values = [values]\n            out.append(supabase.table(table).upsert(values or []).execute().data or []); continue\n\n        out.append({\"error\": f\"unsupported op {op}\", \"step\": step})\n    return out","file_sha":null,"chunk_sha":null,"commit_sha":"HEAD","distance":null},{"id":505,"path":"backend/config/app_config.json","start_line":1,"end_line":3,"content":"{\n  \"mode\": \"live\"\n}","file_sha":null,"chunk_sha":null,"commit_sha":"HEAD","distance":null},{"id":481,"path":"backend/requirements.txt","start_line":1,"end_line":10,"content":"fastapi\nuvicorn\nsupabase\nopenai\nrequests\npython-multipart\nffmpeg-python\ncohere\npython-dotenv\n","file_sha":null,"chunk_sha":null,"commit_sha":"HEAD","distance":null}],"draft":"No automatic changes proposed in this stub.","prompt":"SYSTEM\nYou are RMS GPT, a repo modification and Q&A assistant.\n- Always output strictly as a unified diff patch (git-apply ready) unless explicitly asked for a different format.\n- When planning changes, keep edits minimal, reversible, and scoped only to the specified task and acceptance criteria.\n- Do NOT invent databases, schemas, or large frameworks; keep scope limited to the request.\n- Respect path_prefix and avoid touching unrelated files.\n- If functionality already partially exists, refactor or reorganize code so it meets requirements exactly.\n- If no changes are strictly required, still output a non-empty patch (e.g., adding a comment with a timestamp) so the diff is valid.\n- Prefer small, safe patches with clear verification steps.\n- If uncertain, state assumptions **inside code comments in the patch** rather than prose.\n- All output must be in valid unified diff format ready for `git apply`.\n\nTASK\nRole: RMS GPT (planner+implementer)\nRepo: personal-agent-ste\nBranch: main\nPath prefix: backend/\n\nGoal:\nImplement request logging + correlation IDs via a small FastAPI middleware and a tiny logging utility. Keep it stdlib-only and backward compatible.\n\nRequirements:\n- Create backend/middleware/request_logging.py implementing a BaseHTTPMiddleware that generates/propagates a UUID4 correlation ID per request (header X-Request-Id if present; otherwise create). Store on request.state.correlation_id and a ContextVar. Respect env LOG_REQUESTS (default true): when true, log one line on finish with method, path, status, duration_ms, correlation_id. Always clear the ContextVar.\n- Create backend/logging_utils.py that defines a logging.Filter reading the ContextVar and injecting correlation_id into records, and a configure_logging() helper that sets a base format including %(correlation_id)s (fallback '-' when absent) and attaches the filter to the root logger. No external deps.\n- Wire in backend/main.py (or backend/api.py depending on the prod entrypoint): call configure_logging() at startup and add the middleware. Do not change existing response shapes. Skip /health in request logs, but still set correlation_id.\n- Do not touch unrelated files; keep diffs minimal and under backend/.\n\nAcceptance Criteria:\n- New files exist: backend/middleware/request_logging.py, backend/logging_utils.py.\n- App init calls configure_logging() and adds the middleware.\n- Every request gets a correlation_id; with LOG_REQUESTS=true, a single structured line is logged with method, path, status, duration_ms, correlation_id; with LOG_REQUESTS=false, only middleware request lines are suppressed but other logs still include correlation_id.\n- /health behavior unchanged.\n\nVerification Steps:\n1) Deploy and set LOG_REQUESTS=true. Call /health and one /app/api/* endpoint; run 'fly logs --since 5m' and observe correlation_id, method, path, status, duration_ms.\n2) Set LOG_REQUESTS=false and repeat; middleware request lines are suppressed while app logs still show correlation_id.\n\nConstraints:\n- Python stdlib only; no new heavy deps.\n- Minimal, reversible patch; respect path_prefix.\n\nOutput format (CRITICAL):\nReturn ONLY a unified diff (git-apply ready). DO NOT return JSON, hits, context, or any wrapper—just the diff text starting with 'diff --git'.\n\nCONTEXT\n[1] backend/api.py:1–87@HEAD\n```\n# backend/api.py\nfrom __future__ import annotations\nimport os\nfrom pathlib import Path\n\nfrom fastapi import FastAPI, HTTPException\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom fastapi.responses import HTMLResponse, FileResponse\nfrom fastapi.staticfiles import StaticFiles\nfrom pydantic import BaseModel\nfrom dotenv import load_dotenv\n\n# Load .env for SUPABASE etc.\nload_dotenv()\n\n# your existing router entry\nfrom backend.agents.router_agent import route_request\n\nBASE = \"/app\"  # matches your frontend base\napp = FastAPI(title=\"Personal Agents API\")\n\n# ---------- SPA static serving at /app/ ----------\n# Serve built assets from frontend/dist (Vite build) and index fallback for SPA routes.\nDIST_DIR = (Path(__file__).resolve().parent.parent / \"frontend\" / \"dist\").resolve()\nINDEX_FILE = DIST_DIR / \"index.html\"\n\n# Serve built asset files (Vite emits to dist/assets/*). With base='/app/', URLs are /app/assets/...\nif (DIST_DIR / \"assets\").exists():\n    app.mount(f\"{BASE}/assets\", StaticFiles(directory=str(DIST_DIR / \"assets\")), name=\"assets\")\n\ndef _index_response() -> HTMLResponse:\n    if INDEX_FILE.exists():\n        return HTMLResponse(INDEX_FILE.read_text(encoding=\"utf-8\"))\n    raise HTTPException(status_code=404, detail=\"Frontend build not found. Run `npm run build` in /frontend.\")\n\n@app.get(BASE, include_in_schema=False, response_class=HTMLResponse)\ndef serve_index_root():\n    # GET /app -> index.html\n    return _index_response()\n\n@app.get(f\"{BASE}/\", include_in_schema=False, response_class=HTMLResponse)\ndef serve_index_slash():\n    # GET /app/ -> index.html\n    return _index_response()\n\n@app.get(f\"{BASE}\" + \"/{path:path}\", include_in_schema=False)\ndef spa_fallback(path: str):\n    # Let API continue to be handled by your /app/api/* routes\n    if path.startswith(\"api\"):\n        raise HTTPException(status_code=404)\n    # If a real file was requested (e.g., /app/assets/...), serve it directly\n    candidate = DIST_DIR / path\n    if candidate.is_file():\n        return FileResponse(str(candidate))\n    # Otherwise, return index.html for client-side routes\n    return _index_response()\n\n# CORS for local dev (frontend vite port)\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"http://localhost:5173\", \"http://127.0.0.1:5173\"],\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\nclass RouteIn(BaseModel):\n    text: str\n    client_meta: dict | None = None\n    user_id: str | None = \"web-guest\"\n\n@app.post(f\"{BASE}/api/route\")\ndef route(incoming: RouteIn):\n    try:\n        agent, result = route_request(query=incoming.text, user_id=incoming.user_id or \"web-guest\")\n        # result might already be a dict/str from your make_response; normalize\n        if isinstance(result, dict):\n            payload = result\n        else:\n            payload = {\"agent\": agent, \"intent\": \"unknown\", \"message\": str(result)}\n        # attach meta if present\n        if incoming.client_meta:\n            payload.setdefault(\"meta\", {})[\"client_meta\"] = incoming.client_meta\n        return payload\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n\n```\n\n[2] backend/main.py:1–225@HEAD\n```\n# backend/main.py\nfrom __future__ import annotations\n\nimport os\nimport json\nfrom typing import Any, Dict, Tuple\n\nfrom fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse, RedirectResponse, HTMLResponse, FileResponse\nfrom fastapi.staticfiles import StaticFiles\nfrom pathlib import Path\nfrom starlette.middleware.base import BaseHTTPMiddleware\n\nfrom dotenv import load_dotenv\nload_dotenv()\n\n# ✅ package-qualified imports (works when running: uvicorn backend.main:app)\nfrom backend.agents.router_agent import route_request\nfrom backend.agents.repo_agent import propose_changes, answer_about_repo\nfrom backend.utils.nl_formatter import ensure_natural\nfrom backend.utils.agent_protocol import AgentResponse\nfrom backend.services import conversation as conv\n\n\napp = FastAPI(title=\"Personal Agent API\")\n\n# backend/main.py\nfrom fastapi import FastAPI\nimport os\n\napp = FastAPI()\n\n@app.get(\"/app/api/debug/supabase-key\")\nasync def debug_supabase_key():\n    key = os.getenv(\"SUPABASE_SERVICE_ROLE\")\n    if key:\n        return {\"SUPABASE_SERVICE_ROLE_start\": key[:8] + \"...\"}\n    return {\"SUPABASE_SERVICE_ROLE\": None}\n\n\n# -------------------- Health --------------------\n@app.get(\"/health\")\ndef health():\n    return {\"status\": \"ok\"}\n\n@app.get(\"/app/api/repo/health\")\ndef repo_health():\n    # Simple probe the Repo endpoints are up (and which model is configured)\n    return {\"ok\": True, \"model\": os.getenv(\"CHAT_MODEL\", \"gpt-5\")}\n\n@app.get(\"/\", include_in_schema=False)\ndef root_redirect():\n    return RedirectResponse(url=\"/app/\")\n\n# -------------------- Repo endpoints (bypass router) --------------------\n@app.post(\"/app/api/repo/query\")\ndef repo_query(payload: Dict[str, Any]):\n    q = (payload or {}).get(\"task\") or (payload or {}).get(\"question\") or (payload or {}).get(\"q\")\n    if not q:\n        raise HTTPException(status_code=400, detail=\"Missing 'task'/'question'/'q'\")\n    repo   = payload.get(\"repo\", \"personal-agent-ste\")\n    branch = payload.get(\"branch\", \"main\")\n    prefix = payload.get(\"path_prefix\")\n    k      = int(payload.get(\"k\", 8))\n    commit = payload.get(\"commit\")\n    session = payload.get(\"session\")\n    thread_n = payload.get(\"thread_n\")\n\n    try:\n        return answer_about_repo(\n            q,\n            repo=repo,\n            branch=branch,\n            k=k,\n            path_prefix=prefix,\n            commit=commit,\n            session=session,\n            thread_n=thread_n,\n        )\n    except Exception as e:\n        # bubble up precise error so we can see the RPC’s complaint\n        raise HTTPException(status_code=400, detail=str(e))\n\n\n@app.post(\"/app/api/repo/plan\")\ndef repo_plan(payload: Dict[str, Any]):\n    task = payload.get(\"task\")\n    if not task:\n        raise HTTPException(status_code=400, detail=\"Missing 'task'\")\n    repo   = payload.get(\"repo\", \"personal-agent-ste\")\n    branch = payload.get(\"branch\", \"main\")\n    prefix = payload.get(\"path_prefix\")  # e.g., \"backend/\" or \"frontend/\"\n    k      = int(payload.get(\"k\", 12))\n    session = payload.get(\"session\")\n    thread_n = payload.get(\"thread_n\")\n\n    out = propose_changes(\n        task,\n        repo=repo,\n        branch=branch,\n        commit=\"HEAD\",\n        k=k,\n        path_prefix=prefix,\n        session=session,\n        thread_n=thread_n,\n    )\n    return out\n\n\n@app.post(\"/app/api/repo/memory/reset\")\ndef repo_memory_reset(payload: Dict[str, Any]):\n    session = (payload or {}).get(\"session\")\n    if not session:\n        raise HTTPException(status_code=400, detail=\"Missing 'session'\")\n    deleted = conv.clear_session(session)\n    return {\"ok\": True, \"session\": session, \"deleted\": deleted}\n\n@app.post(\"/app/api/repo/memory/config\")\ndef repo_memory_config(payload: Dict[str, Any]):\n    session = (payload or {}).get(\"session\")\n    n = (payload or {}).get(\"n\")\n    if not session or n is None:\n        raise HTTPException(status_code=400, detail=\"Missing 'session' or 'n'\")\n    conv.set_session_n(session, int(n))\n    return {\"ok\": True, \"session\": session, \"n\": conv.get_session_n(session) or conv.default_n()}\n\n@app.get(\"/app/api/repo/memory/export\")\ndef repo_memory_export(session: str, limit: int = 50):\n    if not session:\n        raise HTTPException(status_code=400, detail=\"Missing 'session'\")\n    return {\"ok\": True, \"session\": session, \"limit\": int(limit), \"messages\": conv.export_messages(session, limit)}\n\n# -------------------- Middleware --------------------\nclass NaturalLanguageMiddleware(BaseHTTPMiddleware):\n    async def dispatch(self, request: Request, call_next):\n        try:\n            response = await call_next(request)\n\n            # Only transform JSONResponse payloads\n            if not isinstance(response, JSONResponse):\n                return response\n\n            # Clone response body safely\n            body_bytes = b\"\"\n            try:\n                async for chunk in response.body_iterator:  # type: ignore[attr-defined]\n                    body_bytes += chunk\n            except Exception:\n                return response  # if we can't read it, return as-is\n\n            response.body_iterator = None  # prevent double iteration\n\n            # If not JSON, passthrough\n            try:\n                payload = json.loads(body_bytes.decode(\"utf-8\"))\n            except Exception:\n                return JSONResponse(\n                    content=body_bytes.decode(\"utf-8\") if body_bytes else None,\n                    status_code=response.status_code,\n                )\n\n            # Naturalize\n            try:\n                formatted = ensure_natural(payload)\n            except Exception as e:\n                formatted = {\n                    \"agent\": (payload.get(\"agent\") if isinstance(payload, dict) else \"system\"),\n                    \"intent\": \"error\",\n                    \"message\": f\"Formatting error: {e}\",\n                    \"raw\": payload,\n                }\n\n            return JSONResponse(content=formatted, status_code=response.status_code)\n\n        except Exception as e:\n            return JSONResponse(\n                content={\"agent\": \"system\", \"intent\": \"error\", \"message\": f\"Middleware error: {e}\"},\n                status_code=500,\n            )\n\napp.add_middleware(NaturalLanguageMiddleware)\n\n# -------------------- Helpers --------------------\ndef _extract_query(query: str | None, body: Dict[str, Any] | None) -> Tuple[str | None, Dict[str, Any] | None]:\n    \"\"\"\n    Accepts either:\n      - form 'query'\n      - JSON { query | prompt | q }\n    \"\"\"\n    if query:\n        return query, body\n    if body and isinstance(body, dict):\n        q = body.get(\"query\") or body.get(\"prompt\") or body.get(\"q\")\n        return q, body\n    return None, body\n\ndef _normalize(agent: str, raw_result: Any) -> AgentResponse:\n    if isinstance(raw_result, str):\n        return {\"agent\": agent, \"intent\": \"say\", \"message\": raw_result}\n    if isinstance(raw_result, dict):\n        if \"agent\" not in raw_result:\n            raw_result = {\"agent\": agent, **raw_result}\n        raw_result.setdefault(\"intent\", \"unknown\")\n        return raw_result  # type: ignore[return-value]\n    if isinstance(raw_result, list):\n        return {\"agent\": agent, \"intent\": \"list\", \"data\": raw_result}\n    return {\"agent\": agent, \"intent\": \"unknown\", \"message\": str(raw_result)}\n\n# -------------------- Universal request endpoint (router path) --------------------\n@app.post(\"/api/request\")\n@app.post(\"/app/api/request\")\n@app.post(\"/api/route\")       # alias to support earlier clients/tests\n@app.post(\"/app/api/route\")   # alias to support earlier clients/tests\nasync def handle_request(request: Request):\n    # Try JSON first (don’t declare Body param so form requests don’t get validated as JSON)\n    body: Dict[str, Any] | None = None\n    try:\n        if request.headers.get(\"content-type\", \"\").lower().startswith(\"application/json\"):\n            body = await request.json()\n            if not isinstance(body, dict):\n                body = None\n    except Exception:\n        body = None\n\n    # Fall back to form field\n```\n\n[3] backend/main.py:1–71@HEAD\n```\n# alias to support earlier clients/tests\nasync def handle_request(request: Request):\n    # Try JSON first (don’t declare Body param so form requests don’t get validated as JSON)\n    body: Dict[str, Any] | None = None\n    try:\n        if request.headers.get(\"content-type\", \"\").lower().startswith(\"application/json\"):\n            body = await request.json()\n            if not isinstance(body, dict):\n                body = None\n    except Exception:\n        body = None\n\n    # Fall back to form fields\n    form_query: str | None = None\n    if body is None:\n        try:\n            form = await request.form()\n            if form:\n                form_query = form.get(\"query\") or form.get(\"prompt\") or form.get(\"q\")  # type: ignore[assignment]\n        except Exception:\n            form_query = None\n\n    q, _ = _extract_query(form_query, body)\n    if not q:\n        return JSONResponse(\n            {\"agent\": \"system\", \"intent\": \"error\", \"message\": \"Missing 'query' in form or JSON body\"},\n            status_code=400,\n        )\n\n    agent, raw_result = route_request(q)\n    resp = _normalize(agent, raw_result)\n\n    # Pre-format so clients without middleware still get a nice shape\n    try:\n        natural = ensure_natural(resp)\n    except Exception as e:\n        natural = {\n            \"agent\": resp.get(\"agent\", \"system\"),\n            \"intent\": \"error\",\n            \"message\": f\"Formatting error: {e}\",\n            \"raw\": resp,\n        }\n\n    return JSONResponse(natural)\n\n# -------------------- Static frontend (SPA at /app) --------------------\nstatic_dir = os.path.join(os.path.dirname(__file__), \"static\")\n\nif os.path.isdir(static_dir):\n    INDEX_FILE = Path(static_dir) / \"index.html\"\n\n    # Serve the SPA at /app (and optionally /)\n    app.mount(\"/app\", StaticFiles(directory=static_dir, html=True), name=\"static\")\n\n    @app.get(\"/app\", include_in_schema=False, response_class=HTMLResponse)\n    @app.get(\"/app/\", include_in_schema=False, response_class=HTMLResponse)\n    def serve_index():\n        if INDEX_FILE.exists():\n            return HTMLResponse(INDEX_FILE.read_text(encoding=\"utf-8\"))\n        raise HTTPException(status_code=404, detail=\"Frontend build not found.\")\n\n    # SPA fallback: return index.html for any /app/* path that isn't a real file\n    @app.get(\"/app/{path:path}\", include_in_schema=False, response_class=HTMLResponse)\n    def spa_fallback(path: str):\n        candidate = Path(static_dir) / path\n        if candidate.is_file():\n            return FileResponse(str(candidate))\n        if INDEX_FILE.exists():\n            return HTMLResponse(INDEX_FILE.read_text(encoding=\"utf-8\"))\n        raise HTTPException(status_code=404, detail=\"Frontend build not found.\")\n\n```\n\n[4] backend/rms.py:1–36@HEAD\n```\n# backend/rms.py\nfrom __future__ import annotations\nimport os\nfrom typing import Any, Dict, List\nfrom backend.services.supabase_service import supabase\n\nSUPABASE_RPC_1536 = \"repo_search_1536\"\nSUPABASE_RPC_1024 = \"repo_search_1024\"\n\ndef repo_search_raw(params: Dict[str, Any], *, dims: int) -> List[Dict[str, Any]]:\n    \"\"\"Dispatch to the right RPC based on dims. Params must include:\n       q (list[float]), repo, branch_in, prefix, match_count\n    \"\"\"\n    rpc_name = SUPABASE_RPC_1024 if dims == 1024 else SUPABASE_RPC_1536\n    # PostgREST requires named args for RPCs\n    payload = {\n        \"repo_in\": params[\"repo\"],\n        \"branch_in\": params[\"branch_in\"],\n        \"prefix_in\": params.get(\"prefix\"),\n        \"query_embedding\": params[\"q\"],\n        \"match_count\": params.get(\"match_count\", 8),\n    }\n    res = supabase.rpc(rpc_name, payload).execute()\n    return res.data or []\n\ndef repo_search(vec: List[float], *, repo: str, branch: str, k: int, prefix: str|None) -> List[Dict[str, Any]]:\n    dims = len(vec)\n    params = {\n        \"q\": vec,\n        \"repo\": repo,\n        \"branch_in\": branch,\n        \"prefix\": prefix,\n        \"match_count\": k,\n    }\n    return repo_search_raw(params, dims=dims)\n\n```\n\n[5] backend/static/assets/index-DNJdlJfi.js:1–21@HEAD\n```\n(function(){const t=document.createElement(\"link\").relList;if(t&&t.supports&&t.supports(\"modulepreload\"))return;for(const r of document.querySelectorAll('link[rel=\"modulepreload\"]'))s(r);new MutationObserver(r=>{for(const o of r)if(o.type===\"childList\")for(const i of o.addedNodes)i.tagName===\"LINK\"&&i.rel===\"modulepreload\"&&s(i)}).observe(document,{childList:!0,subtree:!0});function n(r){const o={};return r.integrity&&(o.integrity=r.integrity),r.referrerPolicy&&(o.referrerPolicy=r.referrerPolicy),r.crossOrigin===\"use-credentials\"?o.credentials=\"include\":r.crossOrigin===\"anonymous\"?o.credentials=\"omit\":o.credentials=\"same-origin\",o}function s(r){if(r.ep)return;r.ep=!0;const o=n(r);fetch(r.href,o)}})();/**\n* @vue/shared v3.5.18\n* (c) 2018-present Yuxi (Evan) You and Vue contributors\n* @license MIT\n**//*! #__NO_SIDE_EFFECTS__ */function hs(e){const t=Object.create(null);for(const n of e.split(\",\"))t[n]=1;return n=>n in t}const Y={},Et=[],De=()=>{},Yo=()=>!1,Sn=e=>e.charCodeAt(0)===111&&e.charCodeAt(1)===110&&(e.charCodeAt(2)>122||e.charCodeAt(2)<97),ps=e=>e.startsWith(\"onUpdate:\"),fe=Object.assign,gs=(e,t)=>{const n=e.indexOf(t);n>-1&&e.splice(n,1)},Xo=Object.prototype.hasOwnProperty,q=(e,t)=>Xo.call(e,t),H=Array.isArray,Rt=e=>En(e)===\"[object Map]\",Tr=e=>En(e)===\"[object Set]\",D=e=>typeof e==\"function\",ne=e=>typeof e==\"string\",ft=e=>typeof e==\"symbol\",ee=e=>e!==null&&typeof e==\"object\",Mr=e=>(ee(e)||D(e))&&D(e.then)&&D(e.catch),Ir=Object.prototype.toString,En=e=>Ir.call(e),Zo=e=>En(e).slice(8,-1),$r=e=>En(e)===\"[object Object]\",ms=e=>ne(e)&&e!==\"NaN\"&&e[0]!==\"-\"&&\"\"+parseInt(e,10)===e,Dt=hs(\",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted\"),Rn=e=>{const t=Object.create(null);return n=>t[n]||(t[n]=e(n))},ei=/-(\\w)/g,Se=Rn(e=>e.replace(ei,(t,n)=>n?n.toUpperCase():\"\")),ti=/\\B([A-Z])/g,at=Rn(e=>e.replace(ti,\"-$1\").toLowerCase()),Cn=Rn(e=>e.charAt(0).toUpperCase()+e.slice(1)),Hn=Rn(e=>e?`on${Cn(e)}`:\"\"),lt=(e,t)=>!Object.is(e,t),cn=(e,...t)=>{for(let n=0;n<e.length;n++)e[n](...t)},Yn=(e,t,n,s=!1)=>{Object.defineProperty(e,t,{configurable:!0,enumerable:!1,writable:s,value:n})},Xn=e=>{const t=parseFloat(e);return isNaN(t)?e:t};let Hs;const Pn=()=>Hs||(Hs=typeof globalThis<\"u\"?globalThis:typeof self<\"u\"?self:typeof window<\"u\"?window:typeof global<\"u\"?global:{});function _s(e){if(H(e)){const t={};for(let n=0;n<e.length;n++){const s=e[n],r=ne(s)?oi(s):_s(s);if(r)for(const o in r)t[o]=r[o]}return t}else if(ne(e)||ee(e))return e}const ni=/;(?![^(]*\\))/g,si=/:([^]+)/,ri=/\\/\\*[^]*?\\*\\//g;function oi(e){const t={};return e.replace(ri,\"\").split(ni).forEach(n=>{if(n){const s=n.split(si);s.length>1&&(t[s[0].trim()]=s[1].trim())}}),t}function An(e){let t=\"\";if(ne(e))t=e;else if(H(e))for(let n=0;n<e.length;n++){const s=An(e[n]);s&&(t+=s+\" \")}else if(ee(e))for(const n in e)e[n]&&(t+=n+\" \");return t.trim()}const ii=\"itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly\",li=hs(ii);function Nr(e){return!!e||e===\"\"}const Fr=e=>!!(e&&e.__v_isRef===!0),ot=e=>ne(e)?e:e==null?\"\":H(e)||ee(e)&&(e.toString===Ir||!D(e.toString))?Fr(e)?ot(e.value):JSON.stringify(e,Lr,2):String(e),Lr=(e,t)=>Fr(t)?Lr(e,t.value):Rt(t)?{[`Map(${t.size})`]:[...t.entries()].reduce((n,[s,r],o)=>(n[jn(s,o)+\" =>\"]=r,n),{})}:Tr(t)?{[`Set(${t.size})`]:[...t.values()].map(n=>jn(n))}:ft(t)?jn(t):ee(t)&&!H(t)&&!$r(t)?String(t):t,jn=(e,t=\"\")=>{var n;return ft(e)?`Symbol(${(n=e.description)!=null?n:t})`:e};/**\n* @vue/reactivity v3.5.18\n* (c) 2018-present Yuxi (Evan) You and Vue contributors\n* @license MIT\n**/let me;class ci{constructor(t=!1){this.detached=t,this._active=!0,this._on=0,this.effects=[],this.cleanups=[],this._isPaused=!1,this.parent=me,!t&&me&&(this.index=(me.scopes||(me.scopes=[])).push(this)-1)}get active(){return this._active}pause(){if(this._active){this._isPaused=!0;let t,n;if(this.scopes)for(t=0,n=this.scopes.length;t<n;t++)this.scopes[t].pause();for(t=0,n=this.effects.length;t<n;t++)this.effects[t].pause()}}resume(){if(this._active&&this._isPaused){this._isPaused=!1;let t,n;if(this.scopes)for(t=0,n=this.scopes.length;t<n;t++)this.scopes[t].resume();for(t=0,n=this.effects.length;t<n;t++)this.effects[t].resume()}}run(t){if(this._active){const n=me;try{return me=this,t()}finally{me=n}}}on(){++this._on===1&&(this.prevScope=me,me=this)}off(){this._on>0&&--this._on===0&&(me=this.prevScope,this.prevScope=void 0)}stop(t){if(this._active){this._active=!1;let n,s;for(n=0,s=this.effects.length;n<s;n++)this.effects[n].stop();for(this.effects.length=0,n=0,s=this.cleanups.length;n<s;n++)this.cleanups[n]();if(this.cleanups.length=0,this.scopes){for(n=0,s=this.scopes.length;n<s;n++)this.scopes[n].stop(!0);this.scopes.length=0}if(!this.detached&&this.parent&&!t){const r=this.parent.scopes.pop();r&&r!==this&&(this.parent.scopes[this.index]=r,r.index=this.index)}this.parent=void 0}}}function ui(){return me}let Z;const Dn=new WeakSet;class Hr{constructor(t){this.fn=t,this.deps=void 0,this.depsTail=void 0,this.flags=5,this.next=void 0,this.cleanup=void 0,this.scheduler=void 0,me&&me.active&&me.effects.push(this)}pause(){this.flags|=64}resume(){this.flags&64&&(this.flags&=-65,Dn.has(this)&&(Dn.delete(this),this.trigger()))}notify(){this.flags&2&&!(this.flags&32)||this.flags&8||Dr(this)}run(){if(!(this.flags&1))return this.fn();this.flags|=2,js(this),kr(this);const t=Z,n=Re;Z=this,Re=!0;try{return this.fn()}finally{Kr(this),Z=t,Re=n,this.flags&=-3}}stop(){if(this.flags&1){for(let t=this.deps;t;t=t.nextDep)bs(t);this.deps=this.depsTail=void 0,js(this),this.onStop&&this.onStop(),this.flags&=-2}}trigger(){this.flags&64?Dn.add(this):this.scheduler?this.scheduler():this.runIfDirty()}runIfDirty(){Zn(this)&&this.run()}get dirty(){return Zn(this)}}let jr=0,kt,Kt;function Dr(e,t=!1){if(e.flags|=8,t){e.next=Kt,Kt=e;return}e.next=kt,kt=e}function ys(){jr++}function vs(){if(--jr>0)return;if(Kt){let t=Kt;for(Kt=void 0;t;){const n=t.next;t.next=void 0,t.flags&=-9,t=n}}let e;for(;kt;){let t=kt;for(kt=void 0;t;){const n=t.next;if(t.next=void 0,t.flags&=-9,t.flags&1)try{t.trigger()}catch(s){e||(e=s)}t=n}}if(e)throw e}function kr(e){for(let t=e.deps;t;t=t.nextDep)t.version=-1,t.prevActiveLink=t.dep.activeLink,t.dep.activeLink=t}function Kr(e){let t,n=e.depsTail,s=n;for(;s;){const r=s.prevDep;s.version===-1?(s===n&&(n=r),bs(s),fi(s)):t=s,s.dep.activeLink=s.prevActiveLink,s.prevActiveLink=void 0,s=r}e.deps=t,e.depsTail=n}function Zn(e){for(let t=e.deps;t;t=t.nextDep)if(t.dep.version!==t.version||t.dep.computed&&(Vr(t.dep.computed)||t.dep.version!==t.version))return!0;return!!e._dirty}function Vr(e){if(e.flags&4&&!(e.flags&16)||(e.flags&=-17,e.globalVersion===zt)||(e.globalVersion=zt,!e.isSSR&&e.flags&128&&(!e.deps&&!e._dirty||!Zn(e))))return;e.flags|=2;const t=e.dep,n=Z,s=Re;Z=e,Re=!0;try{kr(e);const r=e.fn(e._value);(t.version===0||lt(r,e._value))&&(e.flags|=128,e._value=r,t.version++)}catch(r){throw t.version++,r}finally{Z=n,Re=s,Kr(e),e.flags&=-3}}function bs(e,t=!1){const{dep:n,prevSub:s,nextSub:r}=e;if(s&&(s.nextSub=r,e.prevSub=void 0),r&&(r.prevSub=s,e.nextSub=void 0),n.subs===e&&(n.subs=s,!s&&n.computed)){n.computed.flags&=-5;for(let o=n.computed.deps;o;o=o.nextDep)bs(o,!0)}!t&&!--n.sc&&n.map&&n.map.delete(n.key)}function fi(e){const{prevDep:t,nextDep:n}=e;t&&(t.nextDep=n,e.prevDep=void 0),n&&(n.prevDep=t,e.nextDep=void 0)}let Re=!0;const Br=[];function Qe(){Br.push(Re),Re=!1}function Je(){const e=Br.pop();Re=e===void 0?!0:e}function js(e){const{cleanup:t}=e;if(e.cleanup=void 0,t){const n=Z;Z=void 0;try{t()}finally{Z=n}}}let zt=0;class ai{constructor(t,n){this.sub=t,this.dep=n,this.version=n.version,this.nextDep=this.prevDep=this.nextSub=this.prevSub=this.prevActiveLink=void 0}}class xs{constructor(t){this.computed=t,this.version=0,this.activeLink=void 0,this.subs=void 0,this.map=void 0,this.key=void 0,this.sc=0,this.__v_skip=!0}track(t){if(!Z||!Re||Z===this.computed)return;let n=this.activeLink;if(n===void 0||n.sub!==Z)n=this.activeLink=new ai(Z,this),Z.deps?(n.prevDep=Z.depsTail,Z.depsTail.nextDep=n,Z.depsTail=n):Z.deps=Z.depsTail=n,Ur(n);else if(n.version===-1&&(n.version=this.version,n.nextDep)){const s=n.nextDep;s.prevDep=n.prevDep,n.prevDep&&(n.prevDep.nextDep=s),n.prevDep=Z.depsTail,n.nextDep=void 0,Z.depsTail.nextDep=n,Z.depsTail=n,Z.deps===n&&(Z.deps=s)}return n}trigger(t){this.version++,zt++,this.notify(t)}notify(t){ys();try{for(let n=this.subs;n;n=n.prevSub)n.sub.notify()&&n.sub.dep.notify()}finally{vs()}}}function Ur(e){if(e.dep.sc++,e.sub.flags&4){const t=e.dep.computed;if(t&&!e.dep.subs){t.flags|=20;for(let s=t.deps;s;s=s.nextDep)Ur(s)}const n=e.dep.subs;n!==e&&(e.prevSub=n,n&&(n.nextSub=e)),e.dep.subs=e}}const es=new WeakMap,mt=Symbol(\"\"),ts=Symbol(\"\"),Qt=Symbol(\"\");function ie(e,t,n){if(Re&&Z){let s=es.get(e);s||es.set(e,s=new Map);let r=s.get(n);r||(s.set(n,r=new xs),r.map=s,r.key=n),r.track()}}function We(e,t,n,s,r,o){const i=es.get(e);if(!i){zt++;return}const c=l=>{l&&l.trigger()};if(ys(),t===\"clear\")i.forEach(c);else{const l=H(e),d=l&&ms(n);if(l&&n===\"length\"){const f=Number(s);i.forEach((h,g)=>{(g===\"length\"||g===Qt||!ft(g)&&g>=f)&&c(h)})}else switch((n!==void 0||i.has(void 0))&&c(i.get(n)),d&&c(i.get(Qt)),t){case\"add\":l?d&&c(i.get(\"length\")):(c(i.get(mt)),Rt(e)&&c(i.get(ts)));break;case\"delete\":l||(c(i.get(mt)),Rt(e)&&c(i.get(ts)));break;case\"set\":Rt(e)&&c(i.get(mt));break}}vs()}function bt(e){const t=W(e);return t===e?t:(ie(t,\"iterate\",Qt),we(e)?t:t.map(oe))}function On(e){return ie(e=W(e),\"iterate\",Qt),e}const di={__proto__:null,[Symbol.iterator](){return kn(this,Symbol.iterator,oe)},concat(...e){return bt(this).concat(...e.map(t=>H(t)?bt(t):t))},entries(){return kn(this,\"entries\",e=>(e[1]=oe(e[1]),e))},every(e,t){return Ve(this,\"every\",e,t,void 0,arguments)},filter(e,t){return Ve(this,\"filter\",e,t,n=>n.map(oe),arguments)},find(e,t){return Ve(this,\"find\",e,t,oe,arguments)},findIndex(e,t){return Ve(this,\"findIndex\",e,t,void 0,arguments)},findLast(e,t){return Ve(this\n```\n\n[6] backend/agents/router_agent.py:121–240@HEAD\n```\nReturn ONLY minified JSON in one of these schemas:\n\n1) Route to agent:\n{\"agent\":\"<slug>\",\"reason\":\"short reason\",\"confidence\":0.0-1.0,\"rewrite\":\"optional concise task phrasing\"}\n\n2) Answer directly (no agent call):\n{\"agent\":\"none\",\"response\":\"short answer\",\"reason\":\"why no agent is needed\",\"confidence\":0.0-1.0}\n\n3) Ask the user to choose (you are unsure which agent fits):\n{\"agent\":\"clarify\",\"question\":\"one short disambiguating question\",\"options\":[<slugs>],\n \"reason\":\"why you asked\",\"confidence\":0.0-1.0,\"rewrite\":\"optional best-guess task phrasing\"}\n\nHard rules:\n- If at least one agent in AGENT_CATALOG plausibly matches the user task, DO NOT choose agent=\"none\".\n- Prefer routing even if your confidence is moderate; use \"clarify\" only when you cannot pick between agents.\n- Use \"rewrite\" to turn vague user text into a crisp, actionable task for the chosen agent.\n\nGuidance (examples):\n- \"show today's meals\" -> route to the agent whose description/capabilities mention meals/meal planning/meal logs.\n- \"mark lunch done\" -> route to that same meals agent; include a rewrite like \"mark today's lunch complete\".\n- \"log today's workout\" -> route to workouts agent.\n- \"how much did I spend last week?\" -> route to finance agent.\n- \"hi\", \"thanks\", \"tell me a joke\" -> agent=\"none\".\n\"\"\"\n\n\ndef _build_prompt(user_text: str, user_id: str) -> str:\n    return (\n        f\"{ROUTER_SYSTEM}\\n\\n\"\n        f\"AGENT_CATALOG:\\n{json.dumps(_catalog())}\\n\\n\"\n        f\"USER_REQUEST:\\n{user_text}\\n\\n\"\n        \"Return ONLY the JSON.\"\n    )\n\ndef _parse_json(raw: str) -> Optional[Dict[str, Any]]:\n    if not isinstance(raw, str): return None\n    s = raw.strip()\n    if s.startswith(\"```\"):\n        s = s.strip(\"`\")\n        lines = s.splitlines()\n        if lines and lines[0].lower().startswith(\"json\"):\n            s = \"\\n\".join(lines[1:])\n    start, end = s.find(\"{\"), s.rfind(\"}\")\n    if start == -1 or end == -1 or end <= start: return None\n    try:\n        return json.loads(s[start:end+1])\n    except Exception:\n        logger.exception(\"[router] LLM parse error\")\n        return None\n\ndef _llm_route(user_text: str, user_id: str) -> Optional[Dict[str, Any]]:\n    try:\n        raw = reason_with_memory(\n            agent_name=\"router\",\n            query=_build_prompt(user_text, user_id),\n            namespace=\"routing\",\n            k=4,\n        )\n        obj = _parse_json(raw)\n        if not obj:\n            # LLM returned something we couldn't parse\n            _log_decision(\"router\", user_id, user_text, False, reason=\"parse_failed\")\n            return None\n\n        try:\n            obj[\"confidence\"] = float(obj.get(\"confidence\", 0))\n        except Exception:\n            obj[\"confidence\"] = 0.0\n\n        # Soft log that the LLM produced a routing proposal (final success/fail is logged later)\n        _log_decision(\n            \"router\",\n            user_id,\n            user_text,\n            True,\n            reason=\"llm_routed\",\n            confidence=obj.get(\"confidence\"),\n        )\n        return obj\n\n    except Exception as e:\n        logger.exception(\"[router] reasoner failed\")\n        _log_decision(\"router\", user_id, user_text, False, reason=\"reasoner_failed\", error=str(e))\n        return None\n\n\n# ----- public entry -----\ndef route_request(query: str, user_id: str = \"anon\") -> Tuple[str, dict | str]:\n    reg = _load_registry()\n    allowed = list(reg.keys())\n    print(f\"[router] incoming user={user_id!r} query={query!r} allowed={allowed}\")\n\n    try:\n        decision = _llm_route(query, user_id)\n\n        # Direct answer\n        if decision and decision.get(\"agent\") == \"none\":\n            _log_decision(\"router\", user_id, query, True, extra={\"reason\": decision.get(\"reason\"), \"confidence\": decision.get(\"confidence\")})\n            return \"router\", make_response(agent=\"router\", intent=\"answer\",\n                                        data={\"response\": decision.get(\"response\"),\n                                                \"reason\": decision.get(\"reason\"),\n                                                \"confidence\": decision.get(\"confidence\")})\n\n\n        # Clarify (or low confidence)\n        if not decision or decision.get(\"agent\") == \"clarify\" or decision.get(\"confidence\", 0) < 0.55:\n            opts = decision.get(\"options\") if decision and decision.get(\"options\") else allowed\n            q = decision.get(\"question\") if decision and decision.get(\"question\") else \"Which agent should handle this?\"\n            _log_decision(\"router\", user_id, query, False, extra={\"reason\": (decision or {}).get(\"reason\"), \"confidence\": (decision or {}).get(\"confidence\")})\n            return \"router\", make_response(agent=\"router\", intent=\"clarify\",\n                                        data={\"question\": q, \"options\": opts,\n                                                \"suggested_rewrite\": decision.get(\"rewrite\") if decision else None})\n\n\n        # Normal route\n        agent = str(decision.get(\"agent\") or \"\").strip().lower()\n        if agent in reg:\n            text = decision.get(\"rewrite\") or query\n\n            # Log to routing memory for future retrieval\n```\n\n[7] backend/agents/meals_agent.py:1–79@HEAD\n```\n# backend/agents/meals_agent.py\nfrom ._base_agent import BaseAgent\n\nFALLBACK_SYSTEM = \"\"\"\nYou are a meals operator. Plan floating daily meal cards (no fixed times), support swaps,\nand log completions. Read/write tables: recipe_templates, meal_plan, meal_log.\n\nReturn ONLY compact JSON with keys:\n- thoughts (string)\n- operations (array of {op, table, where?, order?, limit?, set?, values?})\n- response_template? (string)\n\nExamples:\n\n1) Build today's daylist (oldest-first by freshness):\n{\n  \"thoughts\": \"List today's meals from meal_plan by freshness\",\n  \"operations\": [\n    {\"op\":\"select\",\"table\":\"meal_plan\",\"where\":{\"date\":\"{{today}}\"},\"order\":[[\"freshness_rank\",\"asc\"]],\"limit\":50}\n  ]\n}\n\n2) Mark a meal complete and log it:\n{\n  \"thoughts\": \"Mark meal done and insert meal_log\",\n  \"operations\": [\n    {\"op\":\"update\",\"table\":\"meal_plan\",\"where\":{\"id\":\"{{meal_id}}\"},\"set\":{\"status\":\"done\"}},\n    {\"op\":\"insert\",\"table\":\"meal_log\",\"values\":{\n      \"meal_plan_id\":\"{{meal_id}}\",\"ts\":\"{{now}}\",\"notes\":\"auto\"\n    }}\n  ]\n}\n\n3) Add a planned meal for today (1 serving):\n{\n  \"thoughts\": \"Plan a new meal for today\",\n  \"operations\": [\n    {\"op\":\"insert\",\"table\":\"meal_plan\",\"values\":{\n      \"date\":\"{{today}}\",\"recipe_id\":\"{{recipe_id}}\",\"servings\":1,\"status\":\"planned\",\"freshness_rank\":0\n    }}\n  ]\n}\n\"\"\"\n\nclass MealsAgent(BaseAgent):\n    AGENT_META = {\n        \"slug\": \"meals\",\n        \"title\": \"Meals\",\n        \"description\": \"Plan daily meals, swap items, and log completions.\",\n        # Router metadata is inferred if omitted:\n        # \"module_path\": \"agents.meals_agent\",\n        # \"callable_name\": \"class:MealsAgent\",\n        \"namespaces\": [\"meals\"],\n        \"capabilities\": [\"Daylist\",\"Swap\",\"Complete\",\"Plan\"],\n        \"keywords\": [\"meal\",\"meals\",\"eat\",\"food\",\"recipe\",\"daylist\",\"breakfast\",\"lunch\",\"dinner\",\"snack\"],\n        \"status\": \"enabled\",\n        \"version\": \"v1\",\n        # Hints for the planner (also overridable via agent_settings.default_tables)\n        \"default_tables\": [\"recipe_templates\",\"meal_plan\",\"meal_log\"],\n        \"instruction_tags\": [],\n        \"fallback_system\": FALLBACK_SYSTEM,\n        # Post hooks can be configured here or in agent_settings.post_hooks\n        \"post_hooks\": [],\n    }\n\n    # Optional: choose instruction tags dynamically (kept minimal here)\n    def choose_tags(self, user_text: str):\n        text = (user_text or \"\").lower()\n        tags = []\n        if any(w in text for w in [\"plan\", \"add\", \"new meal\", \"daylist\"]):\n            tags.append(\"planning\")\n        if any(w in text for w in [\"swap\", \"replace\"]):\n            tags.append(\"swaps\")\n        if any(w in text for w in [\"done\", \"complete\", \"log\"]):\n            tags.append(\"logging\")\n        return tags\n\ndef handle_meals(query: str):\n    return MealsAgent().handle(query)\n```\n\n[8] backend/agents/mixins.py:1–14@HEAD\n```\nclass SemanticAgentMixin:\n    \"\"\"Optional mixin for agents that want semantic memory + tools.\"\"\"\n    namespace: str = \"generic\"\n\n    def build_knowledge(self):\n        \"\"\"\n        Return rows to embed:\n        [{\"doc_id\": \"...\", \"text\": \"...\", \"metadata\": {...}}, ...]\n        \"\"\"\n        return []\n\n    def tools(self) -> dict:\n        \"\"\"Return {tool_name: callable} mapping (deterministic helpers).\"\"\"\n        return {}\n```\n\n[9] backend/agents/router_agent.py:1–120@HEAD\n```\n# backend/agents/router_agent.py\nfrom __future__ import annotations\nfrom typing import Tuple, Dict, Any, Optional, List, Callable\nimport json, logging, time, importlib\n\n# ✅ package-qualified imports\nfrom backend.services.supabase_service import supabase\nfrom backend.reasoner.policy import reason_with_memory\nfrom backend.utils.agent_protocol import make_response\nfrom backend.semantics.store import upsert as emb_upsert\nimport time\n\nfrom backend.services.supabase_service import supabase\n\ndef _log_decision(agent_slug: str, user_id: str, query_text: str, was_success: bool,\n                  latency_ms: int = 0, reason: str | None = None,\n                  confidence: float | None = None, error: str | None = None,\n                  extra: dict | None = None) -> None:\n    try:\n        payload = {\n            \"agent_slug\": agent_slug,\n            \"user_id\": user_id,\n            \"query_text\": query_text,\n            \"was_success\": was_success,\n            \"latency_ms\": latency_ms,\n            \"extra\": {\n                \"reason\": reason,\n                \"confidence\": confidence,\n                \"error\": error,\n                **(extra or {})\n            }\n        }\n        payload[\"extra\"] = {k: v for k, v in payload[\"extra\"].items() if v is not None}\n        supabase.table(\"agent_decisions\").insert(payload).execute()\n    except Exception:\n        logger.exception(\"[router] failed to log agent_decision\")\n\n\n\nROUTER_VERSION = \"2025-08-09-supabase-registry-v1\"\nlogger = logging.getLogger(\"router\")\nprint(f\"[router] loaded version={ROUTER_VERSION}\")\n\n# ----- Registry cache (auto refresh) -----\n_REG: Dict[str, Dict[str, Any]] = {}\n_LAST: float = 0.0\n_TTL = 60.0  # seconds\n\ndef _load_registry(force: bool = False) -> Dict[str, Dict[str, Any]]:\n    global _REG, _LAST\n    if not force and _REG and (time.time() - _LAST < _TTL):\n        return _REG\n\n    rows = []\n    try:\n        res = supabase.table(\"agents\").select(\"*\").eq(\"status\", \"enabled\").execute()\n        print(\"[router] fetched agents:\", [ (r.get(\"slug\"), r.get(\"module_path\"), r.get(\"callable_name\"), r.get(\"status\")) for r in rows ])\n\n        rows = getattr(res, \"data\", None) or []\n    except Exception:\n        logger.exception(\"[router] failed to read agents table\")\n        rows = []\n\n    reg: Dict[str, Dict[str, Any]] = {}\n    for r in rows:\n        slug = (r.get(\"slug\") or \"\").strip().lower()\n        module_path = r.get(\"module_path\") or f\"backend.agents.{slug}_agent\"\n        callable_name = r.get(\"callable_name\") or f\"handle_{slug}\"\n        if module_path.startswith(\"agents.\"):\n            module_path = \"backend.\" + module_path\n        try:\n            mod = importlib.import_module(module_path)\n            if callable_name.startswith(\"class:\"):\n                cls_name = callable_name.split(\":\", 1)[1]\n                Cls = getattr(mod, cls_name)\n                inst = Cls()\n                handle: Callable[[str], dict | str] = lambda q, _i=inst: _i.handle(q)\n            else:\n                handle = getattr(mod, callable_name)\n            reg[slug] = {\n                \"handle\": handle,\n                \"desc\": r.get(\"description\") or slug,\n                \"capabilities\": r.get(\"capabilities\") or [],\n                \"namespaces\": r.get(\"namespaces\") or [slug],\n            }\n            print(f\"[router] registered agent: {slug} -> {module_path}.{callable_name}\")\n        except Exception:\n            logger.exception(f\"[router] failed to import {module_path}.{callable_name} for slug={slug}\")\n\n    _REG = reg\n    _LAST = time.time()\n    print(f\"[router] registry loaded: {sorted(_REG.keys())}\")\n    return _REG\n\ndef _catalog() -> Dict[str, Any]:\n    reg = _load_registry()\n    return {k: {\"desc\": v[\"desc\"], \"capabilities\": v[\"capabilities\"]} for k, v in reg.items()}\n\n# ----- LLM prompt -----\nROUTER_SYSTEM = \"\"\"You are the routing coordinator for a personal-agents app.\n\nYou MUST choose an agent from AGENT_CATALOG when a user request is task-like or data-related\nand any catalog agent plausibly fits. Only use {\"agent\":\"none\", ...} for small-talk, greetings,\nor purely informational questions you can answer in one short sentence without calling an agent.\n\nReturn ONLY minified JSON in one of these schemas:\n\n1) Route to agent:\n{\"agent\":\"<slug>\",\"reason\":\"short reason\",\"confidence\":0.0-1.0,\"rewrite\":\"optional concise task phrasing\"}\n\n2) Answer directly (no agent call):\n{\"agent\":\"none\",\"response\":\"short answer\",\"reason\":\"why no agent is needed\",\"confidence\":0.0-1.0}\n\n3) Ask the user to choose (you are unsure which agent fits):\n{\"agent\":\"clarify\",\"question\":\"one short disambiguating question\",\"options\":[<slugs>],\n \"reason\":\"why you asked\",\"confidence\":0.0-1.0,\"rewrite\":\"optional best-guess task phrasing\"}\n\nHard rules:\n- If at least one agent in AGENT_CATALOG plausibly matches the user task, DO NOT choose agent=\"none\".\n- Prefer routing even if your confidence is moderate; use \"clarify\" only when you cannot pick between agents.\n```\n\n[10] backend/agents/_op_engine.py:1–98@HEAD\n```\n# backend/agents/_op_engine.py\nfrom typing import Any, Dict, List\nimport re, json\nfrom backend.services.supabase_service import supabase\n\ndef table_columns(table: str) -> List[str]:\n    try:\n        sample = supabase.table(table).select(\"*\").limit(1).execute().data or []\n        return list(sample[0].keys()) if sample else []\n    except Exception:\n        return []\n\ndef _prune_where(where: Any, columns: List[str]) -> Any:\n    if not where or not columns: return where\n    cols = set(columns)\n    if isinstance(where, str):\n        parts = re.split(r\"\\s+and\\s+\", where, flags=re.I)\n        kept = [p for p in parts if re.match(r\"\\s*([a-zA-Z0-9_]+)\\s*=\", p) and p.split(\"=\")[0].strip() in cols]\n        return \" AND \".join(kept) if kept else None\n    if isinstance(where, list):\n        pruned = [w for w in (_prune_where(w, columns) for w in where) if w]\n        return pruned or None\n    if isinstance(where, dict):\n        return {k:v for k,v in where.items() if k in cols} or None\n    return None\n\ndef _apply_where(q, where: Any):\n    if not where: return q\n    if isinstance(where, str):\n        parts = re.split(r\"\\s+and\\s+\", where, flags=re.I)\n        for cond in parts:\n            m = re.match(r\"\\s*([a-zA-Z0-9_]+)\\s*=\\s*(.+)\\s*$\", cond)\n            if not m: continue\n            key, val = m.group(1), m.group(2).strip().strip(\"'\\\"\")\n            q = q.eq(key, val)\n        return q\n    if isinstance(where, list):\n        for w in where: q = _apply_where(q, w)\n        return q\n    if isinstance(where, dict):\n        for k, v in where.items():\n            if isinstance(v, dict):\n                for oper, val in v.items():\n                    o = str(oper).lower()\n                    if   o == \">=\": q = q.gte(k, val)\n                    elif o == \"<=\": q = q.lte(k, val)\n                    elif o == \">\":  q = q.gt(k, val)\n                    elif o == \"<\":  q = q.lt(k, val)\n                    elif o == \"!=\": q = q.neq(k, val)\n                    elif o == \"like\": q = q.like(k, val)\n                    else: q = q.eq(k, val)\n            else:\n                q = q.eq(k, v)\n        return q\n    return q\n\ndef execute_ops(ops: List[Dict[str, Any]]) -> List[Any]:\n    out: List[Any] = []\n    for step in ops:\n        op = str(step.get(\"op\",\"\")).lower()\n        table = step.get(\"table\")\n        if not op or not table:\n            out.append({\"error\":\"missing op/table\",\"step\":step}); continue\n\n        cols = table_columns(table)\n        where = _prune_where(step.get(\"where\"), cols)\n\n        if op == \"select\":\n            q = supabase.table(table).select(\"*\")\n            q = _apply_where(q, where or {})\n            for pair in (step.get(\"order\") or []):\n                if isinstance(pair, list) and len(pair)==2:\n                    q = q.order(pair[0], desc=(str(pair[1]).lower()==\"desc\"))\n            if step.get(\"limit\"): q = q.limit(int(step[\"limit\"]))\n            out.append(q.execute().data or []); continue\n\n        if op == \"update\":\n            q = supabase.table(table).update(step.get(\"set\") or {})\n            q = _apply_where(q, where or {})\n            out.append(q.execute().data or []); continue\n\n        if op == \"insert\":\n            values = step.get(\"values\"); \n            if isinstance(values, dict): values = [values]\n            out.append(supabase.table(table).insert(values or []).execute().data or []); continue\n\n        if op == \"delete\":\n            q = supabase.table(table).delete()\n            q = _apply_where(q, where or {})\n            out.append(q.execute().data or []); continue\n\n        if op == \"upsert\":\n            values = step.get(\"values\"); \n            if isinstance(values, dict): values = [values]\n            out.append(supabase.table(table).upsert(values or []).execute().data or []); continue\n\n        out.append({\"error\": f\"unsupported op {op}\", \"step\": step})\n    return out\n```\n\n[11] backend/config/app_config.json:1–3@HEAD\n```\n{\n  \"mode\": \"live\"\n}\n```\n\n[12] backend/requirements.txt:1–10@HEAD\n```\nfastapi\nuvicorn\nsupabase\nopenai\nrequests\npython-multipart\nffmpeg-python\ncohere\npython-dotenv\n\n```","meta":{"system_prompt":"You are RMS GPT, a repo modification and Q&A assistant.\n- Always output strictly as a unified diff patch (git-apply ready) unless explicitly asked for a different format.\n- When planning changes, keep edits minimal, reversible, and scoped only to the specified task and acceptance criteria.\n- Do NOT invent databases, schemas, or large frameworks; keep scope limited to the request.\n- Respect path_prefix and avoid touching unrelated files.\n- If functionality already partially exists, refactor or reorganize code so it meets requirements exactly.\n- If no changes are strictly required, still output a non-empty patch (e.g., adding a comment with a timestamp) so the diff is valid.\n- Prefer small, safe patches with clear verification steps.\n- If uncertain, state assumptions **inside code comments in the patch** rather than prose.\n- All output must be in valid unified diff format ready for `git apply`."}}