BEGIN_FILE backend/logging_utils.py
import logging
import os
import time
import uuid
from contextvars import ContextVar
from typing import Optional

from starlette.middleware.base import BaseHTTPMiddleware
from starlette.requests import Request
from starlette.responses import Response

# Context variable for correlation ID with default '-'
correlation_id_ctx: ContextVar[str] = ContextVar("correlation_id", default="-")

class CorrelationIdFilter(logging.Filter):
    def filter(self, record: logging.LogRecord) -> bool:
        try:
            record.correlation_id = correlation_id_ctx.get("-")
        except Exception:
            record.correlation_id = "-"
        return True

_LOGGING_CONFIGURED = False

def _truthy_env(name: str, default: str = "true") -> bool:
    val = os.getenv(name, default)
    if val is None:
        val = default
    return str(val).strip().lower() in {"true", "1", "t", "yes"}

def setup_logging() -> None:
    global _LOGGING_CONFIGURED
    if _LOGGING_CONFIGURED:
        return

    fmt = "%(asctime)s %(levelname)s [%(correlation_id)s] %(name)s: %(message)s"
    formatter = logging.Formatter(fmt)
    corr_filter = CorrelationIdFilter()

    root = logging.getLogger()
    # Ensure at least one stream handler with our formatter
    has_handler = False
    for h in list(root.handlers):
        has_handler = True
        # Do not override existing formatters aggressively; but ensure our filter is present
        _add_filter_if_missing(h, corr_filter)
    if not has_handler:
        sh = logging.StreamHandler()
        sh.setFormatter(formatter)
        _add_filter_if_missing(sh, corr_filter)
        root.addHandler(sh)

    # Also attach the filter to the root logger itself (idempotently)
    _add_logger_filter_if_missing(root, corr_filter)

    # Apply filter to common loggers as well
    common_loggers = [
        "uvicorn",
        "uvicorn.error",
        "uvicorn.access",
        "fastapi",
        "request",
        "backend",
    ]
    for name in common_loggers:
        lg = logging.getLogger(name)
        _add_logger_filter_if_missing(lg, corr_filter)
        for h in list(lg.handlers):
            _add_filter_if_missing(h, corr_filter)

    _LOGGING_CONFIGURED = True

def _add_filter_if_missing(handler: logging.Handler, flt: logging.Filter) -> None:
    for existing in handler.filters:
        if isinstance(existing, CorrelationIdFilter):
            return
    handler.addFilter(flt)

def _add_logger_filter_if_missing(logger: logging.Logger, flt: logging.Filter) -> None:
    for existing in logger.filters:
        if isinstance(existing, CorrelationIdFilter):
            return
    logger.addFilter(flt)

class RequestLoggingMiddleware(BaseHTTPMiddleware):
    def __init__(self, app):
        super().__init__(app)
        self.logger = logging.getLogger("request")
        self.log_requests = _truthy_env("LOG_REQUESTS", "true")

    async def dispatch(self, request: Request, call_next):
        cid = str(uuid.uuid4())
        token = correlation_id_ctx.set(cid)
        # expose on request.state
        try:
            setattr(request.state, "correlation_id", cid)
        except Exception:
            pass

        start = time.perf_counter()
        client = getattr(request.client, "host", None)
        method = request.method
        path = request.url.path

        if self.log_requests:
            self.logger.info("request start %s %s client=%s", method, path, client)

        try:
            response: Response = await call_next(request)
            duration = time.perf_counter() - start
            try:
                response.headers["X-Correlation-ID"] = cid
            except Exception:
                pass
            if self.log_requests:
                clen: Optional[str] = response.headers.get("content-length")
                self.logger.info(
                    "request end %s %s status=%s duration=%.3fs bytes=%s",
                    method,
                    path,
                    getattr(response, "status_code", "?"),
                    duration,
                    clen,
                )
            return response
        except Exception:
            # Always log errors regardless of LOG_REQUESTS
            self.logger.exception("request error %s %s client=%s", method, path, client)
            raise
        finally:
            # Reset correlation id context
            try:
                correlation_id_ctx.reset(token)
            except Exception:
                pass
END_FILE
BEGIN_FILE backend/main.py
# backend/main.py
from __future__ import annotations

import os
import json
from typing import Any, Dict, Tuple, Optional, List
from pathlib import Path

from fastapi import FastAPI, Request, HTTPException
from fastapi.responses import JSONResponse, RedirectResponse, HTMLResponse, FileResponse, PlainTextResponse
from fastapi.staticfiles import StaticFiles
from starlette.middleware.base import BaseHTTPMiddleware
# add near your other imports
from backend.agents.repo_agent import generate_artifact_from_task
from fastapi.responses import PlainTextResponse

from dotenv import load_dotenv
load_dotenv()

# Package-qualified imports
from backend.agents.repo_agent import propose_changes, generate_artifact_from_task
# Add these imports after the existing dotenv and package imports
from backend.logging_utils import setup_logging, RequestLoggingMiddleware

app = FastAPI(title="Personal Agent API")

setup_logging()
app.add_middleware(RequestLoggingMiddleware)



# -------------------- Health --------------------
@app.get("/health")
def health():
    return {"status": "ok"}


@app.get("/", include_in_schema=False)
def root_redirect():
    return RedirectResponse(url="/app/")

# ---------- Files-mode validation helpers ----------
from fastapi.responses import PlainTextResponse  # add if not already imported

_ALLOWED_FILES = {"backend/logging_utils.py", "backend/main.py"}
_MAIN_SENTINELS = [
    "from backend.agents.router_agent import route_request",
    "class NaturalLanguageMiddleware(BaseHTTPMiddleware)",
    "app.add_middleware(NaturalLanguageMiddleware)",
]

def _ascii_lf_only(s: str) -> bool:
    try:
        s.encode("ascii")
    except UnicodeEncodeError:
        return False
    return ("\r" not in s) and s.endswith("\n")

def _parse_files_blocks(text: str) -> dict[str, str]:
    files: dict[str, str] = {}
END_FILE
