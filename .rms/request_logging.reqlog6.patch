diff --git a/backend/logging_utils.py b/backend/logging_utils.py
--- /dev/null
+++ b/backend/logging_utils.py
@@ -0,0 +1,128 @@
+from __future__ import annotations
+import logging
+import time
+import uuid
+from contextvars import ContextVar
+from typing import Optional
+
+from starlette.middleware.base import BaseHTTPMiddleware
+from starlette.requests import Request
+
+# Context var to hold correlation ID per request
+correlation_id_var: ContextVar[str] = ContextVar("correlation_id", default="-")
+
+
+def get_correlation_id() -> str:
+    try:
+        return correlation_id_var.get()
+    except Exception:
+        return "-"
+
+
+class CorrelationIdFilter(logging.Filter):
+    def filter(self, record: logging.LogRecord) -> bool:
+        # Inject 'correlation_id' into log records for formatters that reference it
+        try:
+            record.correlation_id = get_correlation_id()
+        except Exception:
+            record.correlation_id = "-"
+        return True
+
+
+_LOGGING_CONFIGURED = False
+
+
+def setup_logging(level: Optional[int] = None) -> None:
+    """
+    Configure logging to include correlation IDs. Safe to call multiple times.
+    """
+    global _LOGGING_CONFIGURED
+    if _LOGGING_CONFIGURED:
+        return
+
+    filt = CorrelationIdFilter()
+
+    # If no handlers yet, set a sensible default configuration.
+    root = logging.getLogger()
+    if not root.handlers:
+        logging.basicConfig(
+            level=level or logging.INFO,
+            format="%(asctime)s %(levelname)s [%(correlation_id)s] %(name)s: %(message)s",
+        )
+
+    # Attach filter to all known handlers
+    def _attach(logger_name: str) -> None:
+        lg = logging.getLogger(logger_name)
+        if lg is None:
+            return
+        for h in lg.handlers:
+            try:
+                h.addFilter(filt)
+            except Exception:
+                pass
+        # Also ensure logger itself has the filter for handlers added later
+        try:
+            lg.addFilter(filt)
+        except Exception:
+            pass
+
+    for name in ("", "uvicorn", "uvicorn.access", "uvicorn.error", "fastapi"):
+        _attach(name)
+
+    _LOGGING_CONFIGURED = True
+
+
+class RequestLoggingMiddleware(BaseHTTPMiddleware):
+    """
+    Middleware that:
+      - Generates a UUID correlation ID per request and stores it in a ContextVar.
+      - Logs start and end of each request with the correlation ID.
+      - Adds X-Request-ID response header.
+    """
+    async def dispatch(self, request: Request, call_next):
+        cid = uuid.uuid4().hex
+        token = correlation_id_var.set(cid)
+        logger = logging.getLogger("request")
+        path = getattr(request.url, "path", "/")
+        method = request.method
+        client_ip = request.client.host if request.client else "-"
+        start = time.perf_counter()
+        logger.info(">> %s %s from %s", method, path, client_ip)
+        try:
+            response = await call_next(request)
+            duration_ms = int((time.perf_counter() - start) * 1000)
+            response.headers["X-Request-ID"] = cid
+            logger.info("<< %s %s %s %d %dms", method, path, response.media_type or "-", response.status_code, duration_ms)
+            return response
+        except Exception as e:
+            duration_ms = int((time.perf_counter() - start) * 1000)
+            logger.exception("!! %s %s error after %dms: %s", method, path, duration_ms, e)
+            raise
+        finally:
+            try:
+                correlation_id_var.reset(token)
+            except Exception:
+                pass
+
+
+def apply_standard_middleware(app) -> None:
+    """
+    Convenience helper to apply CORS and request logging middleware and configure logging.
+    Note: This function is intentionally optional. If you prefer, call setup_logging() and
+    add RequestLoggingMiddleware explicitly in your app.
+    """
+    setup_logging()
+    try:
+        # Import locally to avoid forcing CORSMiddleware import in callers unless used
+        from fastapi.middleware.cors import CORSMiddleware
+        app.add_middleware(
+            CORSMiddleware,
+            allow_origins=["http://localhost:5173", "http://127.0.0.1:5173"],
+            allow_credentials=True,
+            allow_methods=["*"],
+            allow_headers=["*"],
+        )
+    except Exception:
+        # If CORS isn't available or app can't accept it, continue without raising
+        logging.getLogger("request").warning("CORS middleware not applied")
+    app.add_middleware(RequestLoggingMiddleware)
diff --git a/backend/main.py b/backend/main.py
--- a/backend/main.py
+++ b/backend/main.py
@@ -17,6 +17,7 @@ from dotenv import load_dotenv
 load_dotenv()
 
 # âœ… package-qualified imports (works when running: uvicorn backend.main:app)
+from backend.logging_utils import RequestLoggingMiddleware, setup_logging
 from backend.agents.router_agent import route_request
 from backend.agents.repo_agent import propose_changes, answer_about_repo
 from backend.utils.nl_formatter import ensure_natural
 from backend.utils.agent_protocol import AgentResponse
@@ -140,6 +141,9 @@ class NaturalLanguageMiddleware(BaseHTTPMiddleware):
             )
 
 app.add_middleware(NaturalLanguageMiddleware)
+# Configure logging with correlation IDs and apply request logging middleware
+setup_logging()
+app.add_middleware(RequestLoggingMiddleware)
 
 # -------------------- Helpers --------------------
 def _extract_query(query: str | None, body: Dict[str, Any] | None) -> Tuple[str | None, Dict[str, Any] | None]:
     """
